<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C4 - C In Four Functions | HackThe4O4</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="4個函數，528行代碼實現可自舉的C語言編譯器C4怎麼工作？ 模擬程式運作機制定義了簡單的vm（虛擬機器）的暫存器，程式運行的資料和程式碼段等透過解析輸入檔的字元流，生產資料段和程式碼段的內容透過讀取程式碼段的內容，模擬執行，輸出結果。特別說明 這裡的模擬執行其實就是特定的符號映射成一般的c語言的程式設計過程： 如模擬執行的程式碼ADD，就是程式設計時的+ 如模擬執行的PRTF，就是呼叫一般的pr">
<meta property="og:type" content="article">
<meta property="og:title" content="C4 - C In Four Functions">
<meta property="og:url" content="https://no-flag.com/2024/12/21/c4/index.html">
<meta property="og:site_name" content="HackThe4O4">
<meta property="og:description" content="4個函數，528行代碼實現可自舉的C語言編譯器C4怎麼工作？ 模擬程式運作機制定義了簡單的vm（虛擬機器）的暫存器，程式運行的資料和程式碼段等透過解析輸入檔的字元流，生產資料段和程式碼段的內容透過讀取程式碼段的內容，模擬執行，輸出結果。特別說明 這裡的模擬執行其實就是特定的符號映射成一般的c語言的程式設計過程： 如模擬執行的程式碼ADD，就是程式設計時的+ 如模擬執行的PRTF，就是呼叫一般的pr">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://no-flag.com/2024/12/21/c4/img/c4.png">
<meta property="og:image" content="https://no-flag.com/2024/12/21/c4/img/c4_1.png">
<meta property="og:image" content="https://no-flag.com/2024/12/21/c4/img/c4_2.png">
<meta property="og:image" content="https://no-flag.com/2024/12/21/c4/img/c4_3.png">
<meta property="og:image" content="https://no-flag.com/2024/12/21/c4/img/c4_4.png">
<meta property="og:image" content="https://no-flag.com/2024/12/21/c4/img/c4_5.png">
<meta property="og:image" content="https://i.imgur.com/pcp5DfL.png">
<meta property="article:published_time" content="2024-12-21T12:32:07.077Z">
<meta property="article:modified_time" content="2024-03-23T18:44:04.012Z">
<meta property="article:author" content="Noflag">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://no-flag.com/2024/12/21/c4/img/c4.png">
  
    <link rel="alternative" href="/atom.xml" title="HackThe4O4" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/cat.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  


<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/mela.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/2024/12/21/hello-world/">About Me</a></li>
				        
							<li><a href="/archives">All articles</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/mela.gif" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/2024/12/21/hello-world/">About Me</a></li>
		        
					<li><a href="/archives">All articles</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-c4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/12/21/c4/" class="article-date">
  	<time datetime="2024-12-21T12:32:07.077Z" itemprop="datePublished">2024-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C4 - C In Four Functions
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="4個函數，528行代碼實現可自舉的C語言編譯器"><a href="#4個函數，528行代碼實現可自舉的C語言編譯器" class="headerlink" title="4個函數，528行代碼實現可自舉的C語言編譯器"></a><strong>4個函數，528行代碼實現可自舉的C語言編譯器</strong></h1><p>C4怎麼工作？</p>
<p>模擬程式運作機制定義了簡單的vm（虛擬機器）的暫存器，程式運行的資料和程式碼段等<br>透過解析輸入檔的字元流，生產資料段和程式碼段的內容<br>透過讀取程式碼段的內容，模擬執行，輸出結果。<br>特別說明</p>
<p>這裡的模擬執行其實就是特定的符號映射成一般的c語言的程式設計過程：</p>
<p>如模擬執行的程式碼ADD，就是程式設計時的+</p>
<p>如模擬執行的PRTF，就是呼叫一般的printf</p>
<p>一句話說就是解析原始碼檔案字元流為內部的特定標識符，然後讀取標識符，執行對應的操作，完成原始程式碼的功能。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rswier/c4/tree/master">https://github.com/rswier/c4/tree/master</a></p>
<p><img src="img/c4.png" alt="Untitled"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p, *lp, <span class="comment">// 原始碼中目前正在處理的位置</span></span><br><span class="line">     *data;   <span class="comment">// 程式碼段</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *e, *le,  <span class="comment">// 程式碼段</span></span><br><span class="line">    *id,      <span class="comment">// 目前正在詞法分析的標識符</span></span><br><span class="line">    *sym,     <span class="comment">// 符號表</span></span><br><span class="line">    tk,       <span class="comment">// 目前的符號</span></span><br><span class="line">    ival,    <span class="comment">// 符號對應的值</span></span><br><span class="line">    ty,       <span class="comment">// 目前表達式的類型</span></span><br><span class="line">    loc,     <span class="comment">// 局部變數在堆疊中的偏移</span></span><br><span class="line">    line,    <span class="comment">// 目前行數</span></span><br><span class="line">    src,     <span class="comment">// 輸出源碼和彙編</span></span><br><span class="line">    debug;   <span class="comment">// 列印執行的指令</span></span><br><span class="line"><span class="comment">// tokens and classes (operators last and in precedence order)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">為何 enum 是從 128 開始的呢？ </span></span><br><span class="line"><span class="comment">主要是因為 ASCII Code 定義的範圍是 0~127 共 128 字元，所以自訂的 token number 必須從 128 開始編號</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Id = identifier 使用者定義的identifier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*運算符</span></span><br><span class="line"><span class="comment">Assign =</span></span><br><span class="line"><span class="comment">Cond ?</span></span><br><span class="line"><span class="comment">Lor ||</span></span><br><span class="line"><span class="comment">Lan &amp;&amp;</span></span><br><span class="line"><span class="comment">Or |</span></span><br><span class="line"><span class="comment">Xor ^</span></span><br><span class="line"><span class="comment">And &amp;</span></span><br><span class="line"><span class="comment">Eq ==</span></span><br><span class="line"><span class="comment">Ne !=</span></span><br><span class="line"><span class="comment">Lt &lt;</span></span><br><span class="line"><span class="comment">Gt &gt;</span></span><br><span class="line"><span class="comment">Le &lt;=</span></span><br><span class="line"><span class="comment">Ge &gt;=</span></span><br><span class="line"><span class="comment">Shl &lt;&lt;</span></span><br><span class="line"><span class="comment">Shr &gt;&gt;</span></span><br><span class="line"><span class="comment">Add +</span></span><br><span class="line"><span class="comment">Sub -</span></span><br><span class="line"><span class="comment">Mul *</span></span><br><span class="line"><span class="comment">Div /</span></span><br><span class="line"><span class="comment">Mod %</span></span><br><span class="line"><span class="comment">Inc ++</span></span><br><span class="line"><span class="comment">Dec --</span></span><br><span class="line"><span class="comment">Brak [</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">id[Class] =</span></span><br><span class="line"><span class="comment">Num 常數數值</span></span><br><span class="line"><span class="comment">Fun 函數</span></span><br><span class="line"><span class="comment">Sys 系統調用</span></span><br><span class="line"><span class="comment">Glo 全域變數</span></span><br><span class="line"><span class="comment">Loc 局部變數</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//支援的標記類別(給詞法分析器next解析成對應的標記)</span></span><br><span class="line"><span class="comment">// C4所支援的輸入原始碼的字元集限定在7-bit ASCII上，所以每個輸入的字元只可能在[0, 127]的閉區間範圍內，所以是128</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">  Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// opcodes</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">通常，LDR 用於將某些內容從記憶體載入到暫存器中，而 STR 用於將某些內容從暫存器儲存到記憶體位址。</span></span><br><span class="line"><span class="comment">sp：stack frame。</span></span><br><span class="line"><span class="comment">a：register 暫存器。</span></span><br><span class="line"><span class="comment">bp：概念跟 rbp(32 bits)/ebp(64 bits) 相同。</span></span><br><span class="line"><span class="comment">pc：program counter，指向當前指令。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虛擬機器指令</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,</span><br><span class="line">       OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,</span><br><span class="line">       OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支援的資料型別</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> CHAR, INT, PTR &#125;;</span><br><span class="line"><span class="comment">//因為作者沒有實作結構體,所以[id]指向的空間被分割為Idsz大小的區塊(模擬結構體)</span></span><br><span class="line"><span class="comment">//當id指向區塊首時,id[0] == id[Tk] 存取的就是Tk成員的資料(一般是指標)</span></span><br><span class="line"><span class="comment">//其實這種做法，在高階語言裡可以理解為：沒有物件的多元素數組，來模擬對象</span></span><br><span class="line"><span class="comment">//以下是符號表的各項：</span></span><br><span class="line"><span class="comment">//Name 指向的是這個identifier的Name</span></span><br><span class="line"><span class="comment">//Type 為資料型別(例如傳回值型別),如CHAR,INT,INT+PTR</span></span><br><span class="line"><span class="comment">//Class 為型別,如Num(常數數值),Fun(函數),Sys(系統呼叫),Glo全域變數,Loc 局部變數</span></span><br><span class="line"><span class="comment">//符號表是一個長數組，每個數組的元素為符號描述，元素長度為Idsz</span></span><br><span class="line"><span class="comment">// identifier offsets (since we can&#x27;t create an ident struct)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由於 c4 不支援 struct，因此使用 enum 來定義 symbol table(called id for c4)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> Tk, Hash, Name, Class, Type, Val, HClass, HType, HVal, Idsz &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//詞法分析開始：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 標識符=輸入的符號</span></span><br><span class="line">  <span class="type">char</span> *pp;<span class="comment">// 標識符的起始位置</span></span><br><span class="line"><span class="comment">//next() function 是根據 p 所指的 String 做 parsing token 的動作。</span></span><br><span class="line"><span class="comment">// 用循環來忽略空白字元,不過不能被詞法分析器辨識的字元都被認為是空白字元 例如 &#x27;@&#x27;, &#x27;$&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> (tk = *p) &#123;<span class="comment">//最外層的 while 大部分情況都不會是終止條件，主要是由 while 內部直接 return，因此 next() 的邏輯是處理完一個 token 後就會直接 return。</span></span><br><span class="line">    ++p;</span><br><span class="line"><span class="comment">// 1、列印輸出訊息</span></span><br><span class="line">    <span class="keyword">if</span> (tk == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (src) &#123;<span class="comment">//命令列指明-s參數,輸出原始碼與對應字節碼</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %.*s&quot;</span>, line, p - lp, lp);</span><br><span class="line">        lp = p;</span><br><span class="line">        <span class="keyword">while</span> (le &lt; e) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%8.4s&quot;</span>, &amp;<span class="string">&quot;LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,&quot;</span></span><br><span class="line">                           <span class="string">&quot;OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,&quot;</span></span><br><span class="line">                           <span class="string">&quot;OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,&quot;</span>[*++le * <span class="number">5</span>]);</span><br><span class="line">          <span class="keyword">if</span> (*le &lt;= ADJ) <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, *++le); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//ADJ之前的指令都有運算元</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++line;<span class="comment">// 行數+1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2、遇到巨集處理操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tk == <span class="string">&#x27;#&#x27;</span>) &#123;<span class="comment">//#由於不支援巨集處理,所以直接跳過</span></span><br><span class="line">      <span class="keyword">while</span> (*p != <span class="number">0</span> &amp;&amp; *p != <span class="string">&#x27;\n&#x27;</span>) ++p;<span class="comment">// 忽略目前行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">這段是主要處理 Keywords。</span></span><br><span class="line"><span class="comment">第一步先算出該 token 的 hash value，然後利用 hash value and name 找尋 symbol table，</span></span><br><span class="line"><span class="comment">如果有找到就回傳該 token enum value；如果找不到就新增 id(symbol)，</span></span><br><span class="line"><span class="comment">並且設定 token enum value 為 Id(133)。</span></span><br><span class="line"><span class="comment">這邊最容易混淆的是 tk 這個 variable：在進入此 code block 之前，tk=*p；</span></span><br><span class="line"><span class="comment">然後在算 hash value 的時候，tk 代表的是 hash value；</span></span><br><span class="line"><span class="comment">最後要 return 前，tk 紀錄的是 token enum value。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 3.解析合法的變數名</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((tk &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; tk &lt;= <span class="string">&#x27;z&#x27;</span>) || (tk &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; tk &lt;= <span class="string">&#x27;Z&#x27;</span>) || tk == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      pp = p - <span class="number">1</span>;<span class="comment">//因為有++p,pp回退一個字元,pp指向 [這個符號] 的首字母</span></span><br><span class="line">      <span class="keyword">while</span> ((*p &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *p &lt;= <span class="string">&#x27;z&#x27;</span>) || (*p &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *p &lt;= <span class="string">&#x27;Z&#x27;</span>) || (*p &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *p &lt;= <span class="string">&#x27;9&#x27;</span>) || *p == <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">        tk = tk * <span class="number">147</span> + *p++;<span class="comment">//計算標識符雜湊值,tk起始時已經等於*p,從p開始解析</span></span><br><span class="line">      tk = (tk &lt;&lt; <span class="number">6</span>) + (p - pp);<span class="comment">//雜湊值加上[符號長度]</span></span><br><span class="line">      id = sym;<span class="comment">//將id指向符號表</span></span><br><span class="line">      <span class="keyword">while</span> (id[Tk]) &#123;</span><br><span class="line"><span class="comment">//根據hash值還有字元來判斷該標識符是否已經儲存了</span></span><br><span class="line">        <span class="keyword">if</span> (tk == id[Hash] &amp;&amp; !<span class="built_in">memcmp</span>((<span class="type">char</span> *)id[Name], pp, p - pp)) </span><br><span class="line">				&#123; </span><br><span class="line"><span class="comment">//找到同名,則tk = id[Tk] (將id看做結構體,訪問其Tk成員,解釋見上)</span></span><br><span class="line">					tk = id[Tk];</span><br><span class="line">					<span class="keyword">return</span>; <span class="comment">//代表該識別碼已經被識別</span></span><br><span class="line">				&#125;</span><br><span class="line">        id = id + Idsz;<span class="comment">//繼續循環identifier表</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//找不到，將新的識別碼儲存到符號表中</span></span><br><span class="line">      id[Name] = (<span class="type">int</span>)pp;</span><br><span class="line">      id[Hash] = tk;<span class="comment">//哈希值</span></span><br><span class="line">      tk = id[Tk] = Id;<span class="comment">//哈希值</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//這三個條件分別處理的是十進位、十六進位、八進位。回傳計算後的 ival and tk=Num。</span></span><br><span class="line"><span class="comment">// 4、解析八進制、十進制、十六進制數字</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tk &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tk &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">// 第一位為數字,認為是數值</span></span><br><span class="line">      <span class="keyword">if</span> (ival = tk - <span class="string">&#x27;0&#x27;</span>) &#123; <span class="keyword">while</span> (*p &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *p &lt;= <span class="string">&#x27;9&#x27;</span>) ival = ival * <span class="number">10</span> + *p++ - <span class="string">&#x27;0&#x27;</span>; &#125;<span class="comment">//第一位不為0,認為是十進制數</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;x&#x27;</span> || *p == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((tk = *++p) &amp;&amp; ((tk &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tk &lt;= <span class="string">&#x27;9&#x27;</span>) || (tk &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; tk &lt;= <span class="string">&#x27;f&#x27;</span>) || (tk &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; tk &lt;= <span class="string">&#x27;F&#x27;</span>)))<span class="comment">//第一位為0,且以x開頭,認為是16進制數</span></span><br><span class="line">          <span class="comment">//這邊處理 16 進位的方式相當有趣，主要是如何把 A~F 轉成 10~15，為何只需要 +9 就可以將 16 進位英文的部份轉成數字？關鍵在於 ‘A’ 的 ASCII code = 65 = ‘0100 0001’，而數字 10 的 2 進位是 ‘1010’，由於 16 進位並不會使用的 MSB 的 4 bits，因此 (tk &amp; 15) 濾掉前面 4 bits。觀察從 A 轉成數字 10 LSB 的差距：‘1010’ - ‘0001’ = ‘1001’ = 9。</span></span><br><span class="line">					ival = ival * <span class="number">16</span> + (tk &amp; <span class="number">15</span>) + (tk &gt;= <span class="string">&#x27;A&#x27;</span> ? <span class="number">9</span> : <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="keyword">while</span> (*p &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *p &lt;= <span class="string">&#x27;7&#x27;</span>) ival = ival * <span class="number">8</span> + *p++ - <span class="string">&#x27;0&#x27;</span>; &#125;<span class="comment">//認為是八進位數</span></span><br><span class="line">      tk = Num;<span class="comment">//token 為數值型,傳回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 5、解析註釋，只支援單行註釋</span></span><br><span class="line"><span class="comment">//這段是處理 Div(/) or comment(//)，回傳tk=Div。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tk == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (*p == <span class="string">&#x27;/&#x27;</span>) &#123;<span class="comment">//兩個&#x27;/&#x27;開頭,單行註釋</span></span><br><span class="line">        ++p;</span><br><span class="line">        <span class="keyword">while</span> (*p != <span class="number">0</span> &amp;&amp; *p != <span class="string">&#x27;\n&#x27;</span>) ++p;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        tk = Div;<span class="comment">//除法</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//這段主要是處理 String，並且將字串存入 data section 中。回傳 data 起始位置 ival = (int)pp;，如果 tk=` 將 token 設為 Num，tk=Num。</span></span><br><span class="line"><span class="comment">//值得一提的是，‘\n’ 需要特別處理，因為在字串處理中，‘\n’ 會被當成兩個字元，但其實在 ASCII 中他是 LF(換行字元)，ASCII code = 10。</span></span><br><span class="line"><span class="comment">// 6、解析字串</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tk == <span class="string">&#x27;\&#x27;&#x27;</span> || tk == <span class="string">&#x27;&quot;&#x27;</span>) &#123;<span class="comment">//引號開頭,認為是字元(字串)</span></span><br><span class="line">      pp = data;</span><br><span class="line">      <span class="keyword">while</span> (*p != <span class="number">0</span> &amp;&amp; *p != tk) &#123;<span class="comment">//直到找到符合的引號為止</span></span><br><span class="line">        <span class="keyword">if</span> ((ival = *p++) == <span class="string">&#x27;\\&#x27;</span>) &#123;<span class="comment">// 解析轉義字符</span></span><br><span class="line">          <span class="keyword">if</span> ((ival = *p++) == <span class="string">&#x27;n&#x27;</span>) ival = <span class="string">&#x27;\n&#x27;</span>;\n<span class="string">&#x27;;// &#x27;</span>\n<span class="string">&#x27; 認為是&#x27;</span>\n<span class="string">&#x27; 其他直接忽略&#x27;</span>\<span class="string">&#x27;轉義</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (tk == &#x27;</span><span class="string">&quot;&#x27;) *data++ = ival;//如果是雙引號,認為是字串,向data拷貝字符</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      ++p;</span></span><br><span class="line"><span class="string">      if (tk == &#x27;&quot;</span><span class="string">&#x27;) ival = (int)pp; else tk = Num;雙引號則ival指向data中字串開始,單引號則認為是數字</span></span><br><span class="line"><span class="string">      return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">//Operator 的部分會轉成 token enum value，其他符號的部分就直接依照 ASCII Code 回傳，這就是為何 token enum value 要從 128 開始，因為不能和 ASCII Code 產生衝突！</span></span><br><span class="line"><span class="string">// 7、解析運算符號，和指令一一對應</span></span><br><span class="line"><span class="string">//經過 next() 後就完成 token parser，並且取得 token enum value(tk)(andival if need)。</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>=<span class="string">&#x27;) &#123; if (*p == &#x27;</span>=<span class="string">&#x27;) &#123; ++p; tk = Eq; &#125; else tk = Assign; return; &#125;//等於,賦值</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>+<span class="string">&#x27;) &#123; if (*p == &#x27;</span>+<span class="string">&#x27;) &#123; ++p; tk = Inc; &#125; else tk = Add; return; &#125;//加,賦值</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>-<span class="string">&#x27;) &#123; if (*p == &#x27;</span>-<span class="string">&#x27;) &#123; ++p; tk = Dec; &#125; else tk = Sub; return; &#125;//減,自增</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>!<span class="string">&#x27;) &#123; if (*p == &#x27;</span>=<span class="string">&#x27;) &#123; ++p; tk = Ne; &#125; return; &#125;//不等於</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>&lt;<span class="string">&#x27;) &#123; if (*p == &#x27;</span>=<span class="string">&#x27;) &#123; ++p; tk = Le; &#125; else if (*p == &#x27;</span>&lt;<span class="string">&#x27;) &#123; ++p; tk = Shl; &#125; else tk = Lt; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>&gt;<span class="string">&#x27;) &#123; if (*p == &#x27;</span>=<span class="string">&#x27;) &#123; ++p; tk = Ge; &#125; else if (*p == &#x27;</span>&gt;<span class="string">&#x27;) &#123; ++p; tk = Shr; &#125; else tk = Gt; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>|<span class="string">&#x27;) &#123; if (*p == &#x27;</span>|<span class="string">&#x27;) &#123; ++p; tk = Lor; &#125; else tk = Or; return; &#125;//邏輯或 || OR</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>&amp;<span class="string">&#x27;) &#123; if (*p == &#x27;</span>&amp;<span class="string">&#x27;) &#123; ++p; tk = Lan; &#125; else tk = And; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>^<span class="string">&#x27;) &#123; tk = Xor; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>%<span class="string">&#x27;) &#123; tk = Mod; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>*<span class="string">&#x27;) &#123; tk = Mul; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>[<span class="string">&#x27;) &#123; tk = Brak; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>?<span class="string">&#x27;) &#123; tk = Cond; return; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == &#x27;</span>~<span class="string">&#x27; || tk == &#x27;</span>;<span class="string">&#x27; || tk == &#x27;</span>&#123;<span class="string">&#x27; || tk == &#x27;</span>&#125;<span class="string">&#x27; || tk == &#x27;</span>(<span class="string">&#x27; || tk == &#x27;</span>)<span class="string">&#x27; || tk == &#x27;</span>]<span class="string">&#x27; || tk == &#x27;</span>,<span class="string">&#x27; || tk == &#x27;</span>:<span class="string">&#x27;) </span></span><br><span class="line"><span class="string">return;;//不做處理</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//表達式分析</span></span><br><span class="line"><span class="string">//lev表示運算子,因為各個&#x27;</span>運算子token是依照優先權<span class="string">&#x27;生序排列的,所以lev大表示優先權高</span></span><br><span class="line"><span class="string">//不做處理</span></span><br><span class="line"><span class="string">void expr(int lev)</span></span><br><span class="line"><span class="string">&#123;  int t, *d;</span></span><br><span class="line"><span class="string">//第一部分利用 recursive descent (parsing)，檢查 symbol table (semantic Analyzer)，直接產生 IR (Code Generator)；如果有需要就會進行第二部分，Operator precedence (parsing)，主要處理四則運算。</span></span><br><span class="line"><span class="string">  if (!tk) &#123; printf(&quot;%d: unexpected eof in expression\n&quot;, line); exit(-1); &#125;// 1、遇到非法輸入直接退出，報錯</span></span><br><span class="line"><span class="string">//Num 數字處理</span></span><br><span class="line"><span class="string">// 2、解析數字表達式</span></span><br><span class="line"><span class="string">  else if (tk == Num) &#123; *++e = IMM; *++e = ival; next(); ty = INT; &#125;//直接取立即數作為表達式值，用IMM 指令將它載入到AX 中</span></span><br><span class="line"><span class="string">//將字串存入 data section 中。回傳 data 起始位置 ival = (int)pp;</span></span><br><span class="line"><span class="string">  else if (tk == &#x27;</span><span class="string">&quot;&#x27;) &#123;</span></span><br><span class="line"><span class="string">    *++e = IMM; *++e = ival; next();</span></span><br><span class="line"><span class="string">    while (tk == &#x27;&quot;</span><span class="string">&#x27;) next();//連續的&#x27;</span><span class="string">&quot;&#x27; 處理C風格多行文字 例如[&quot;</span>abc<span class="string">&quot; &quot;</span>def<span class="string">&quot;]</span></span><br><span class="line"><span class="string">    data = (char *)((int)data + sizeof(int) &amp; -sizeof(int)); ty = PTR;//這邊的 data 有特別做 alignment [https://en.wikipedia.org/wiki/Data_structure_alignment]，最後輸出 IR。</span></span><br><span class="line"><span class="string">//位元組對齊到int，在末尾追加結束符 ty = PTR;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 4、解析回傳類型表達式</span></span><br><span class="line"><span class="string">  else if (tk == Sizeof) &#123;//Sizeof Operator直接計算 sizeof 的大小。</span></span><br><span class="line"><span class="string">    next(); if (tk == &#x27;(&#x27;) next(); else &#123; printf(&quot;</span>%d: open paren expected in <span class="keyword">sizeof</span>\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    ty = INT; if (tk == Int) next(); else if (tk == Char) &#123; next(); ty = CHAR; &#125;</span></span><br><span class="line"><span class="string">    while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;//多層指標,每多一級加PTR</span></span><br><span class="line"><span class="string">    if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;</span>%d: close paren expected in <span class="keyword">sizeof</span>\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    *++e = IMM; *++e = (ty == CHAR) ? sizeof(char) : sizeof(int);//除了char是一位元組,int和多層指標</span></span><br><span class="line"><span class="string">    ty = INT;// 結果都為int型</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 5、解析變數取值與函數呼叫</span></span><br><span class="line"><span class="string">  else if (tk == Id) &#123;//變數處理</span></span><br><span class="line"><span class="string">    d = id; next();//第一個 if 處理 function call，第二個 else if 處理 enum，第三個 else 處理變數。</span></span><br><span class="line"><span class="string">    if (tk == &#x27;(&#x27;) &#123;//lookahead 的技巧。//函數</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">      t = 0;//形參數</span></span><br><span class="line"><span class="string">      while (tk != &#x27;)&#x27;) &#123; expr(Assign); *++e = PSH; ++t; if (tk == &#x27;,&#x27;) next(); &#125;//計算實參的值，壓棧(傳參</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">      if (d[Class] == Sys) *++e = d[Val];</span></span><br><span class="line"><span class="string">      else if (d[Class] == Fun) &#123; *++e = JSR; *++e = d[Val]; &#125;//系統呼叫,如malloc,memset,d[val]為opcode</span></span><br><span class="line"><span class="string">//使用者定義函數,d[Val]為函數入口位址</span></span><br><span class="line"><span class="string">      else &#123; printf(&quot;</span>%d: bad function call\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      if (t) &#123; *++e = ADJ; *++e = t; &#125;//因為用棧傳參,調整棧</span></span><br><span class="line"><span class="string">      ty = d[Type];//函數傳回值類型</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else if (d[Class] == Num) &#123; *++e = IMM; *++e = d[Val]; ty = INT; &#125;//d[Class] == Num,處理枚舉(只有枚舉是Class==Num)</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">第一個 while 處理參數(argument)的部分，並且產生 push into stack 的 IR；</span></span><br><span class="line"><span class="string">接下來的兩個 if 分別處理system call and function call：</span></span><br><span class="line"><span class="string">system call 不做 binding 的動作，只保留 Symbol name；</span></span><br><span class="line"><span class="string">function call 則使用 JSR 指令來跳躍到該函式的真實位址。</span></span><br><span class="line"><span class="string">最後根據參數的數量調整 stack frame pointer。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*//變數</span></span><br><span class="line"><span class="string">//變數先取地址然後再LC/LI</span></span><br><span class="line"><span class="string">    else &#123;</span></span><br><span class="line"><span class="string">      if (d[Class] == Loc) &#123; *++e = LEA; *++e = loc - d[Val]; &#125;//取位址,d[Val]是局部變數偏移量</span></span><br><span class="line"><span class="string">      else if (d[Class] == Glo) &#123; *++e = IMM; *++e = d[Val]; &#125;//取位址,d[Val] 是全域變數指標</span></span><br><span class="line"><span class="string">      else &#123; printf(&quot;</span>%d: undefined variable\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      *++e = ((ty = d[Type]) == CHAR) ? LC : LI;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 6、解析強制轉換，取得轉換的型別，直接修改type的值</span></span><br><span class="line"><span class="string">  else if (tk == &#x27;(&#x27;) &#123;//括號處理 </span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">    if (tk == Int || tk == Char) &#123;//強制型別轉換</span></span><br><span class="line"><span class="string">      t = (tk == Int) ? INT : CHAR; next();</span></span><br><span class="line"><span class="string">      while (tk == Mul) &#123; next(); t = t + PTR; &#125;//指針</span></span><br><span class="line"><span class="string">//第一個 if 處理 type casting，else 則是處理括號的優先權。</span></span><br><span class="line"><span class="string">      if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;</span>%d: bad cast\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      expr(Inc);//高優先權</span></span><br><span class="line"><span class="string">      ty = t;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else &#123;//一般語法括號</span></span><br><span class="line"><span class="string">      expr(Assign);</span></span><br><span class="line"><span class="string">      if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;</span>%d: close paren expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 7.解析指標取值</span></span><br><span class="line"><span class="string">  else if (tk == Mul) &#123;//取指標指向值</span></span><br><span class="line"><span class="string">//recursive-descent call expr()，然後 check type 是否為一階 pointer type (semantic analyzer)，dereference semantic analyze 的過程為 ty=ty-PTR</span></span><br><span class="line"><span class="string">    next(); expr(Inc);//高優先權</span></span><br><span class="line"><span class="string">    if (ty &gt; INT) ty = ty - PTR; else &#123; printf(&quot;</span>%d: bad dereference\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    *++e = (ty == CHAR) ? LC : LI;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;// 8、解析取址操作</span></span><br><span class="line"><span class="string">  else if (tk == And) &#123;//address-of 的部分直接把 LI/LC command 砍掉，register 所存的就會是位址；相較於 derefernece 而言，register 存的是真正的值。//&amp;,取位址操作</span></span><br><span class="line"><span class="string">    next(); expr(Inc);</span></span><br><span class="line"><span class="string">    if (*e == LC || *e == LI) --e; else &#123; printf(&quot;</span>%d: bad address-of\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    ty = ty + PTR;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 9、解析運算符號表達式</span></span><br><span class="line"><span class="string">//expr() 回傳的值會存在 register，因此這邊要產生的 IR 要先把結果 Push 回 stack，然後再設定 register value，最後做運算，結果會 restore into register。</span></span><br><span class="line"><span class="string">  else if (tk == &#x27;!&#x27;) &#123; next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = 0; *++e = EQ; ty = INT; &#125;//!x相當於x==0</span></span><br><span class="line"><span class="string">  else if (tk == &#x27;~&#x27;) &#123; next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = -1; *++e = XOR; ty = INT; &#125;//~x 相當於x ^ -1</span></span><br><span class="line"><span class="string">  else if (tk == Add) &#123; next(); expr(Inc); ty = INT; &#125;</span></span><br><span class="line"><span class="string">  //處理 expr 開頭是 +/- 的 case。</span></span><br><span class="line"><span class="string">	else if (tk == Add) &#123; next(); expr(Inc); ty = INT; &#125;</span></span><br><span class="line"><span class="string">  else if (tk == Sub) &#123;</span></span><br><span class="line"><span class="string">    next(); *++e = IMM;//數值,取負</span></span><br><span class="line"><span class="string">    if (tk == Num) &#123; *++e = -ival; next(); &#125;</span></span><br><span class="line"><span class="string"> else &#123; *++e = -1; *++e = PSH; expr(Inc); *++e = MUL; &#125;//乘-1</span></span><br><span class="line"><span class="string">    ty = INT;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 10、解析自增、自減</span></span><br><span class="line"><span class="string">//pre-increment/pre-decrement：透過插入 Push command 將 register 的值存入 stack 中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//expr() 第一部分處理的都是 expression 開頭的部分，接著第二部分將會展示如何使用 operator-precedence 處理 operator 優先權。</span></span><br><span class="line"><span class="string">  else if (tk == Inc || tk == Dec) &#123;//處理++x,--x//x--,x++在後面處理</span></span><br><span class="line"><span class="string">    t = tk; next(); expr(Inc);</span></span><br><span class="line"><span class="string">//處理++x,--x</span></span><br><span class="line"><span class="string">    if (*e == LC) &#123; *e = PSH; *++e = LC; &#125;//位址壓棧(下面SC/SI用到),再取數</span></span><br><span class="line"><span class="string">    else if (*e == LI) &#123; *e = PSH; *++e = LI; &#125;</span></span><br><span class="line"><span class="string">    else &#123; printf(&quot;</span>%d: bad lvalue in pre-increment\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    *++e = PSH;//將數值壓棧</span></span><br><span class="line"><span class="string">    *++e = IMM; *++e = (ty &gt; PTR) ? sizeof(int) : sizeof(char);//指標則加減一字,否則加減1</span></span><br><span class="line"><span class="string">    *++e = (t == Inc) ? ADD : SUB;//運算</span></span><br><span class="line"><span class="string">    *++e = (ty == CHAR) ? SC : SI;//存回變數</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else &#123; printf(&quot;</span>%d: bad expression\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">//使用 switch，但是 c4 並不支援 switch，因此才會採用多個 if-else。</span></span><br><span class="line"><span class="string">//Operator precedence (parsing)，主要處理四則運算。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//爬山法</span></span><br><span class="line"><span class="string">  //tk為ASCII碼的都不會超過Num=128</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  while (tk &gt;= lev) &#123; // &quot;</span>precedence climbing<span class="string">&quot; or &quot;</span>Top Down Operator Precedence<span class="string">&quot; method</span></span><br><span class="line"><span class="string">    t = ty;//ty在遞迴過程中可能會改變,所以備份目前處理的表達式類型</span></span><br><span class="line"><span class="string">// 11、解析賦值運算</span></span><br><span class="line"><span class="string">//將暫存器的位址 push 到 stack 中，做完後面的運算後，結果通常都會在暫存器中，因此透過 SC/SI 將暫存器的值存到 stack 中的位址。</span></span><br><span class="line"><span class="string">    if (tk == Assign) &#123;//賦值</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">      if (*e == LC || *e == LI) *e = PSH;//左邊被tk=Id中變數部分處理過了,將位址壓棧</span></span><br><span class="line"><span class="string">			 else &#123; printf(&quot;</span>%d: bad lvalue in assignment\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      expr(Assign); *++e = ((ty = t) == CHAR) ? SC : SI;SC : SI;//取得右值expr的值,作為a=expr的結果</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//處理類似 x=y?a:b 判斷式，保留 BZ 指令後面要填位址的空間</span></span><br><span class="line"><span class="string">//然後進行 recursive descent parser for expression，然後塞入 JMP 指令</span></span><br><span class="line"><span class="string">//且一樣保留後面要填位址的空間，展開最後的 expression 後，再填入要 JMP 的位址。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 12、解析三目運算符</span></span><br><span class="line"><span class="string">    else if (tk == Cond) &#123;//x?a:b和if類似,除了不能沒有else</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">      *++e = BZ; d = ++e;</span></span><br><span class="line"><span class="string">      expr(Assign);</span></span><br><span class="line"><span class="string">      if (tk == &#x27;:&#x27;) next(); else &#123; printf(&quot;</span>%d: conditional missing colon\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      *d = (int)(e + 3); *++e = JMP; d = ++e;</span></span><br><span class="line"><span class="string">      expr(Cond);</span></span><br><span class="line"><span class="string">      *d = (int)(e + 1);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//通常牽扯到 Branch/Jump 指令的都會使用類似這種方法：先保留目標位址，等待後面的指令都確定後，才會知道目標位址。</span></span><br><span class="line"><span class="string">    else if (tk == Lor) &#123; next(); *++e = BNZ; d = ++e; expr(Lan); *d = (int)(e + 1); ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Lan) &#123; next(); *++e = BZ;  d = ++e; expr(Or);  *d = (int)(e + 1); ty = INT; &#125;</span></span><br><span class="line"><span class="string"> /*</span></span><br><span class="line"><span class="string">這邊運算子的概念就是先將數值 push into stack frame，然後利用 operator-precedence</span></span><br><span class="line"><span class="string">展開後面的 expression，展開的結果通常會存在 register，</span></span><br><span class="line"><span class="string">運算相關的 command 通常是拿 register 和 stack 做運算，然後將結果存回 register。</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">		else if (tk == Or)  &#123; next(); *++e = PSH; expr(Xor); *++e = OR;  ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Xor) &#123; next(); *++e = PSH; expr(And); *++e = XOR; ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == And) &#123; next(); *++e = PSH; expr(Eq);  *++e = AND; ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Eq)  &#123; next(); *++e = PSH; expr(Lt);  *++e = EQ;  ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Ne)  &#123; next(); *++e = PSH; expr(Lt);  *++e = NE;  ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Lt)  &#123; next(); *++e = PSH; expr(Shl); *++e = LT;  ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Gt)  &#123; next(); *++e = PSH; expr(Shl); *++e = GT;  ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Le)  &#123; next(); *++e = PSH; expr(Shl); *++e = LE;  ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Ge)  &#123; next(); *++e = PSH; expr(Shl); *++e = GE;  ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Shl) &#123; next(); *++e = PSH; expr(Add); *++e = SHL; ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Shr) &#123; next(); *++e = PSH; expr(Add); *++e = SHR; ty = INT; &#125;</span></span><br><span class="line"><span class="string">    //這邊同時處理 pointer 的加法：因為一次 add 一個「單位」。</span></span><br><span class="line"><span class="string">		//int *a;</span></span><br><span class="line"><span class="string">		//c=a+b;</span></span><br><span class="line"><span class="string">		else if (tk == Add) &#123;</span></span><br><span class="line"><span class="string">      next(); *++e = PSH; expr(Mul);</span></span><br><span class="line"><span class="string">      if ((ty = t) &gt; PTR) &#123; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  &#125;//處理指針</span></span><br><span class="line"><span class="string">      *++e = ADD;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//發現多了一個 if 判斷式，這是在處理指標相減計算中間的個數。</span></span><br><span class="line"><span class="string">    else if (tk == Sub) &#123;</span></span><br><span class="line"><span class="string">      next(); *++e = PSH; expr(Mul);</span></span><br><span class="line"><span class="string">      if (t &gt; PTR &amp;&amp; t == ty) &#123; *++e = SUB; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = DIV; ty = INT; &#125;//指標相減</span></span><br><span class="line"><span class="string">      else if ((ty = t) &gt; PTR) &#123; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL; *++e = SUB; &#125;//指標減數值</span></span><br><span class="line"><span class="string">      else *++e = SUB;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Mul) &#123; next(); *++e = PSH; expr(Inc); *++e = MUL; ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Div) &#123; next(); *++e = PSH; expr(Inc); *++e = DIV; ty = INT; &#125;</span></span><br><span class="line"><span class="string">    else if (tk == Mod) &#123; next(); *++e = PSH; expr(Inc); *++e = MOD; ty = INT; &#125;</span></span><br><span class="line"><span class="string">//post-increment 的做法就是先改變 variable 在 stack 中的值，然後再回復成原來的值，並且存在 register 中，最後再進行運算。</span></span><br><span class="line"><span class="string">    else if (tk == Inc || tk == Dec) &#123;</span></span><br><span class="line"><span class="string">      if (*e == LC) &#123; *e = PSH; *++e = LC; &#125;</span></span><br><span class="line"><span class="string">      else if (*e == LI) &#123; *e = PSH; *++e = LI; &#125;</span></span><br><span class="line"><span class="string">      else &#123; printf(&quot;</span>%d: bad lvalue in post-increment\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      *++e = PSH; *++e = IMM; *++e = (ty &gt; PTR) ? sizeof(int) : sizeof(char);</span></span><br><span class="line"><span class="string">      *++e = (tk == Inc) ? ADD : SUB;//先自增/自減</span></span><br><span class="line"><span class="string">      *++e = (ty == CHAR) ? SC : SI;//存到記憶體裡</span></span><br><span class="line"><span class="string">      *++e = PSH; *++e = IMM; *++e = (ty &gt; PTR) ? sizeof(int) : sizeof(char);</span></span><br><span class="line"><span class="string">      *++e = (tk == Inc) ? SUB : ADD;//再反轉操作，保證後自增/自減不影響這次表達式的求值 //PS:我終於知道哪些a=1;b=a+++a++為啥等於3了</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//這部分是處理 array index 的取值到 register 中，中間必須處理一個 array 單位乘以 index，以計算最終位址。</span></span><br><span class="line"><span class="string">    else if (tk == Brak) &#123;// 備份下標</span></span><br><span class="line"><span class="string">      next(); *++e = PSH; expr(Assign);//儲存備份配額,計算下標</span></span><br><span class="line"><span class="string">      if (tk == &#x27;]&#x27;) next(); else &#123; printf(&quot;</span>%d: close bracket expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      if (t &gt; PTR) &#123; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  &#125;//t==PTR時是Char,Char = 0</span></span><br><span class="line"><span class="string">      else if (t &lt; PTR) &#123; printf(&quot;</span>%d: pointer type expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">      *++e = ADD;</span></span><br><span class="line"><span class="string">      *++e = ((ty = t - PTR) == CHAR) ? LC : LI;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else &#123; printf(&quot;</span>%d: compiler error tk=%d\n<span class="string">&quot;, line, tk); exit(-1); &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//處理 “if-else”, “while”, “return”, “&#123;&#125;”, “;”</span></span><br><span class="line"><span class="string">//語句分析</span></span><br><span class="line"><span class="string">void stmt()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  int *a, *b;</span></span><br><span class="line"><span class="string">//*a:代表條件為false時跳到的語句</span></span><br><span class="line"><span class="string">  //*b:為了防止順序執行if-else程式碼,所以執行了true部分時應跳過false部分</span></span><br><span class="line"><span class="string">// 1、解析if語句</span></span><br><span class="line"><span class="string">  if (tk == If) &#123;</span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">    if (tk == &#x27;(&#x27;) </span></span><br><span class="line"><span class="string">		next(); </span></span><br><span class="line"><span class="string">		else &#123; printf(&quot;</span>%d: open paren expected\n<span class="string">&quot;, line); </span></span><br><span class="line"><span class="string">		exit(-1); &#125;</span></span><br><span class="line"><span class="string">    expr(Assign);</span></span><br><span class="line"><span class="string">    if (tk == &#x27;)&#x27;) </span></span><br><span class="line"><span class="string">		next(); </span></span><br><span class="line"><span class="string">		else &#123; </span></span><br><span class="line"><span class="string">		printf(&quot;</span>%d: close paren expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    *++e = BZ;//branch if zero</span></span><br><span class="line"><span class="string">		 b = ++e;//branch address pointer</span></span><br><span class="line"><span class="string">    stmt();// 繼續分析</span></span><br><span class="line"><span class="string">    if (tk == Else) &#123;</span></span><br><span class="line"><span class="string">      *b = (int)(e + 3); // e + 3 位置是else 起始位置</span></span><br><span class="line"><span class="string">			*++e = JMP; </span></span><br><span class="line"><span class="string">			b = ++e; // if 語句 else 之前插入 JMP 跳過Else 部分 // JMP目標</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">      stmt();//分析else 部分</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    *b = (int)(e + 1);//if 語句結束,無論是if BZ 跳轉目標或是 else 之前的JMP的跳轉目標</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 2、解析while語句</span></span><br><span class="line"><span class="string">  else if (tk == While) &#123;//循環</span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">    a = e + 1;// While 迴圈體起始位址</span></span><br><span class="line"><span class="string">    if (tk == &#x27;(&#x27;) next(); else &#123; printf(&quot;</span>%d: open paren expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    expr(Assign);</span></span><br><span class="line"><span class="string">    if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;</span>%d: close paren expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">    *++e = BZ;</span></span><br><span class="line"><span class="string">		 b = ++e;//b = While 語句結束後位址</span></span><br><span class="line"><span class="string">    stmt();//處理While 語句體</span></span><br><span class="line"><span class="string">    *++e = JMP; *++e = (int)a;//無條件跳到While語句開始(包含循環條件的程式碼),實作循環</span></span><br><span class="line"><span class="string">    *b = (int)(e + 1);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 3.解析return語句</span></span><br><span class="line"><span class="string">  else if (tk == Return) &#123;</span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">    if (tk != &#x27;;&#x27;) expr(Assign);// 3.解析return語句</span></span><br><span class="line"><span class="string">    *++e = LEV;// 銷毀函式呼叫棧</span></span><br><span class="line"><span class="string">    if (tk == &#x27;;&#x27;) next(); else &#123; printf(&quot;</span>%d: semicolon expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">//解析複合語句</span></span><br><span class="line"><span class="string">  else if (tk == &#x27;&#123;&#x27;) &#123;</span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">    while (tk != &#x27;&#125;&#x27;) stmt();//複合語句</span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">// 5、解析單句</span></span><br><span class="line"><span class="string">  else if (tk == &#x27;;&#x27;) &#123;</span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else &#123;</span></span><br><span class="line"><span class="string">    expr(Assign);;//一般的語句認為是賦值語句/表達式</span></span><br><span class="line"><span class="string">    if (tk == &#x27;;&#x27;) next(); else &#123; printf(&quot;</span>%d: semicolon expected\n<span class="string">&quot;, line); exit(-1); &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char **argv)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	//fd file descriptor 檔案描述</span></span><br><span class="line"><span class="string">  //bt basetype</span></span><br><span class="line"><span class="string">  //poolsz 一系列池的大小</span></span><br><span class="line"><span class="string">  //ty type 記錄目前標識的類型</span></span><br><span class="line"><span class="string">  int fd, bt, ty, poolsz, *idmain;</span></span><br><span class="line"><span class="string">  int *pc, *sp, *bp, a, cycle; // vm registers 虛擬器的暫存器</span></span><br><span class="line"><span class="string">  int i, *t; // temps</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --argc; ++argv;</span></span><br><span class="line"><span class="string">  if (argc &gt; 0 &amp;&amp; **argv == &#x27;-&#x27; &amp;&amp; (*argv)[1] == &#x27;s&#x27;) &#123; src = 1; --argc; ++argv; &#125;</span></span><br><span class="line"><span class="string">  if (argc &gt; 0 &amp;&amp; **argv == &#x27;-&#x27; &amp;&amp; (*argv)[1] == &#x27;d&#x27;) &#123; debug = 1; --argc; ++argv; &#125;</span></span><br><span class="line"><span class="string">  if (argc &lt; 1) &#123; printf(&quot;</span>usage: c4 [-s] [-d] file ...\n<span class="string">&quot;); return -1; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if ((fd = open(*argv, 0)) &lt; 0) &#123; printf(&quot;</span>could not open(%s)\n<span class="string">&quot;, *argv); return -1; &#125;</span></span><br><span class="line"><span class="string">//Symbol Table and Stack Frame 的大小都是 256KB。//開啟原始檔並讀取到src_pos中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sym：symbol table.</span></span><br><span class="line"><span class="string">e：Assembly Code(IR) output.</span></span><br><span class="line"><span class="string">le：last print IR.</span></span><br><span class="line"><span class="string">sp：Stack Frame.</span></span><br><span class="line"><span class="string">data：data section.</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">//poolsz = 256*1024; // 大小</span></span><br><span class="line"><span class="string">  //給各區域申請空間</span></span><br><span class="line"><span class="string">  poolsz = 256*1024; // arbitrary size</span></span><br><span class="line"><span class="string">  if (!(sym = malloc(poolsz))) &#123; printf(&quot;</span>could not <span class="built_in">malloc</span>(%d) symbol area\n<span class="string">&quot;, poolsz); return -1; &#125;//符號表</span></span><br><span class="line"><span class="string">  if (!(le = e = malloc(poolsz))) &#123; printf(&quot;</span>could not <span class="built_in">malloc</span>(%d) text area\n<span class="string">&quot;, poolsz); return -1; &#125;//文字段</span></span><br><span class="line"><span class="string">  if (!(data = malloc(poolsz))) &#123; printf(&quot;</span>could not <span class="built_in">malloc</span>(%d) data area\n<span class="string">&quot;, poolsz); return -1; &#125;//資料段</span></span><br><span class="line"><span class="string">  if (!(sp = malloc(poolsz))) &#123; printf(&quot;</span>could not <span class="built_in">malloc</span>(%d) <span class="built_in">stack</span> area\n<span class="string">&quot;, poolsz); return -1; &#125;//棧</span></span><br><span class="line"><span class="string">// 起始位置</span></span><br><span class="line"><span class="string">  memset(sym,  0, poolsz);</span></span><br><span class="line"><span class="string">  memset(e,    0, poolsz);</span></span><br><span class="line"><span class="string">  memset(data, 0, poolsz);</span></span><br><span class="line"><span class="string">//根據 enum 從 Char 到 While 一一加入 symbol table 中。</span></span><br><span class="line"><span class="string">//在 next() function 中 id 將會指到 sym =&gt; id = sym; // unwind symbol table locals.</span></span><br><span class="line"><span class="string">// 用詞法分析器先把這些關鍵字放進符號表</span></span><br><span class="line"><span class="string">  p = &quot;</span><span class="type">char</span> <span class="keyword">else</span> <span class="keyword">enum</span> <span class="keyword">if</span> <span class="type">int</span> <span class="keyword">return</span> <span class="keyword">sizeof</span> <span class="keyword">while</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">      &quot;</span>open read close <span class="built_in">printf</span> <span class="built_in">malloc</span> <span class="built_in">free</span> <span class="built_in">memset</span> <span class="built_in">memcmp</span> <span class="built_in">exit</span> <span class="type">void</span> main<span class="string">&quot;;</span></span><br><span class="line"><span class="string">// 預先把關鍵字加進去,id[Tk]修改為和Enum一致</span></span><br><span class="line"><span class="string">  i = Char; while (i &lt;= While) &#123; next(); id[Tk] = i++; &#125; // add keywords to symbol table 從 next() 新增 id(symbol) 之後，會再重新設定 token enum value。</span></span><br><span class="line"><span class="string">//預先把[庫]裡定義的符號(系統函數等) 加進去 Class 賦值為Sys</span></span><br><span class="line"><span class="string">//接下來處理 system call library，從 next() 新增 id(symbol) 之後，會再設定 token class, type, and value。</span></span><br><span class="line"><span class="string">  i = OPEN; while (i &lt;= EXIT) &#123; next(); id[Class] = Sys; id[Type] = INT; id[Val] = i++; &#125; // add library to symbol table</span></span><br><span class="line"><span class="string">// void 認為是char，不支援void類型，將void轉為char</span></span><br><span class="line"><span class="string">  //處理 void and main keyword，另外使用 idmain 紀錄 main `在 symbol table 的位置。</span></span><br><span class="line"><span class="string">	next(); id[Tk] = Char; // handle void type</span></span><br><span class="line"><span class="string">// 記錄main函數的符號id</span></span><br><span class="line"><span class="string">  next(); idmain = id; //指向main函數對應的符號表條目</span></span><br><span class="line"><span class="string">//讀取 source code 到 p(lp=p) 所指的位址，並且關閉 FD。</span></span><br><span class="line"><span class="string">  if (!(lp = p = malloc(poolsz))) &#123; printf(&quot;</span>could not <span class="built_in">malloc</span>(%d) source area\n<span class="string">&quot;, poolsz); return -1; &#125;</span></span><br><span class="line"><span class="string">  if ((i = read(fd, p, poolsz-1)) &lt;= 0) &#123; printf(&quot;</span>read() returned %d\n<span class="string">&quot;, i); return -1; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	p[i] = 0;//字串結尾置0</span></span><br><span class="line"><span class="string">  close(fd);//釋放資源</span></span><br><span class="line"><span class="string">  p[i] = 0;</span></span><br><span class="line"><span class="string">  close(fd);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // parse declarations</span></span><br><span class="line"><span class="string">//在 main() 中，以上面這個 while loop 來 parsing tokens，直到 tk=‘\0’。</span></span><br><span class="line"><span class="string">// 語法分析</span></span><br><span class="line"><span class="string">  line = 1;</span></span><br><span class="line"><span class="string">  next();</span></span><br><span class="line"><span class="string">  while (tk) &#123;</span></span><br><span class="line"><span class="string">//前面兩個 if 分別處理 INT and CHAR，最後一個 if 處理 enum：使用 local variable i 來處理 value of enum id。</span></span><br><span class="line"><span class="string">    bt = INT; // basetype</span></span><br><span class="line"><span class="string">    if (tk == Int) next();//已經有bt == INT</span></span><br><span class="line"><span class="string">    else if (tk == Char) &#123; next(); bt = CHAR; &#125;//char 變數;</span></span><br><span class="line"><span class="string">    else if (tk == Enum) &#123;</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">      if (tk != &#x27;&#123;&#x27;) next();// 似乎忽略了枚舉名,例如 enum xxx&#123;&#125;，去除多餘的空格</span></span><br><span class="line"><span class="string">      if (tk == &#x27;&#123;&#x27;) &#123;</span></span><br><span class="line"><span class="string">        next();</span></span><br><span class="line"><span class="string">        i = 0;//Enum 預設從0 開始</span></span><br><span class="line"><span class="string">        while (tk != &#x27;&#125;&#x27;) &#123;//enum賦值有兩種方式,一種預設從0開始,還有一種可以自己進行賦值</span></span><br><span class="line"><span class="string">				//情況1</span></span><br><span class="line"><span class="string">          if (tk != Id) &#123; printf(&quot;</span>%d: bad <span class="keyword">enum</span> identifier %d\n<span class="string">&quot;, line, tk); return -1; &#125;//不是Identifier 就出錯</span></span><br><span class="line"><span class="string">          next();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          if (tk == Assign) &#123;// 發現賦值語句 如 enum &#123; Num = 128 &#125;;</span></span><br><span class="line"><span class="string">            next();</span></span><br><span class="line"><span class="string">            if (tk != Num) &#123; printf(&quot;</span>%d: bad <span class="keyword">enum</span> initializer\n<span class="string">&quot;, line); return -1; &#125;</span></span><br><span class="line"><span class="string">            i = ival;</span></span><br><span class="line"><span class="string">            next();</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">//將目前的標識加入符號表中</span></span><br><span class="line"><span class="string">          id[Class] = Num; id[Type] = INT; id[Val] = i++;</span></span><br><span class="line"><span class="string">          if (tk == &#x27;,&#x27;) next();//還沒結束,跳過逗號</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        next();</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//解析函數宣告或變數定義</span></span><br><span class="line"><span class="string">//處理 Global variables and Functions。</span></span><br><span class="line"><span class="string">    while (tk != &#x27;;&#x27; &amp;&amp; tk != &#x27;&#125;&#x27;) &#123;</span></span><br><span class="line"><span class="string">      ty = bt;</span></span><br><span class="line"><span class="string">// tk == Mul 表示已*開頭,為指針類型,型別加PTR表示何種類型的指針</span></span><br><span class="line"><span class="string">      while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;</span></span><br><span class="line"><span class="string">//check 是否有重複宣告，是屬於 semantic analyzer 的一部份。</span></span><br><span class="line"><span class="string">      if (tk != Id) &#123; printf(&quot;</span>%d: bad global declaration\n<span class="string">&quot;, line); return -1; &#125;</span></span><br><span class="line"><span class="string">      if (id[Class]) &#123; printf(&quot;</span>%d: duplicate global definition\n<span class="string">&quot;, line); return -1; &#125;//重複全域變數定義,解釋見後</span></span><br><span class="line"><span class="string">      next();</span></span><br><span class="line"><span class="string">      id[Type] = ty;//賦值型別</span></span><br><span class="line"><span class="string">//這邊開始處理 Function declaration。</span></span><br><span class="line"><span class="string">      if (tk == &#x27;(&#x27;) &#123; // 函數</span></span><br><span class="line"><span class="string">//Symbol table 的 class 設定為 Fun 類型，然後將 value 設定為 IR command 的 下個指令(Function 第一個指令)的位址。</span></span><br><span class="line"><span class="string">        id[Class] = Fun;//型別為函數型</span></span><br><span class="line"><span class="string">        id[Val] = (int)(e + 1);//函數指標? 在字節碼中的偏移量/位址</span></span><br><span class="line"><span class="string">        next(); i = 0;</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">這邊會檢查是否重複宣告 parameter。</span></span><br><span class="line"><span class="string">然後將 Symbol table 的資訊 (Class, type, Val) 備份到 HClass, HType, HVal，</span></span><br><span class="line"><span class="string">這邊是實作在 function 內部更改 local variable’s value 將不會影響到 Function 以外的 scope，parameter 也算是 Function local variables。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">        while (tk != &#x27;)&#x27;) &#123;//參數列表</span></span><br><span class="line"><span class="string">          ty = INT;</span></span><br><span class="line"><span class="string">          if (tk == Int) next();</span></span><br><span class="line"><span class="string">          else if (tk == Char) &#123; next(); ty = CHAR; &#125;</span></span><br><span class="line"><span class="string">          while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;//</span></span><br><span class="line"><span class="string">          if (tk != Id) &#123; printf(&quot;</span>%d: bad parameter declaration\n<span class="string">&quot;, line); return -1; &#125;</span></span><br><span class="line"><span class="string">					if (id[Class] == Loc) &#123; printf(&quot;</span>%d: duplicate parameter definition\n<span class="string">&quot;, line); return -1; &#125;//函數參數是局部變量</span></span><br><span class="line"><span class="string">          id[HClass] = id[Class]; id[Class] = Loc;</span></span><br><span class="line"><span class="string">          id[HType]  = id[Type];  id[Type] = ty;</span></span><br><span class="line"><span class="string">          id[HVal]   = id[Val];   id[Val] = i++;//局部變數編號</span></span><br><span class="line"><span class="string">          next();</span></span><br><span class="line"><span class="string">          if (tk == &#x27;,&#x27;) next();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">//為局部變數的入棧申請空間</span></span><br><span class="line"><span class="string">        next();</span></span><br><span class="line"><span class="string">        if (tk != &#x27;&#123;&#x27;) &#123; printf(&quot;</span>%d: bad function definition\n<span class="string">&quot;, line); return -1; &#125;</span></span><br><span class="line"><span class="string">        loc = ++i;//局部變數偏移量</span></span><br><span class="line"><span class="string">        next();</span></span><br><span class="line"><span class="string">        while (tk == Int || tk == Char) &#123;//函數內變數聲明</span></span><br><span class="line"><span class="string">          bt = (tk == Int) ? INT : CHAR;</span></span><br><span class="line"><span class="string">          next();</span></span><br><span class="line"><span class="string">          while (tk != &#x27;;&#x27;) &#123;</span></span><br><span class="line"><span class="string">            ty = bt;</span></span><br><span class="line"><span class="string">            while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;//處理指標型</span></span><br><span class="line"><span class="string">            if (tk != Id) &#123; printf(&quot;</span>%d: bad local declaration\n<span class="string">&quot;, line); return -1; &#125;</span></span><br><span class="line"><span class="string">            if (id[Class] == Loc) &#123; printf(&quot;</span>%d: duplicate local definition\n<span class="string">&quot;, line); return -1; &#125;</span></span><br><span class="line"><span class="string">//備份符號訊息</span></span><br><span class="line"><span class="string">            id[HClass] = id[Class]; id[Class] = Loc;</span></span><br><span class="line"><span class="string">            id[HType]  = id[Type];  id[Type] = ty;</span></span><br><span class="line"><span class="string">            id[HVal]   = id[Val];   id[Val] = ++i;//儲存變數偏移量</span></span><br><span class="line"><span class="string">            next();</span></span><br><span class="line"><span class="string">            if (tk == &#x27;,&#x27;) next();</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          next();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">//為局部變數的入棧申請空間</span></span><br><span class="line"><span class="string">        *++e = ENT; *++e = i - loc;//函式局部變數數目</span></span><br><span class="line"><span class="string">        while (tk != &#x27;&#125;&#x27;) stmt();//語法分析</span></span><br><span class="line"><span class="string">        *++e = LEV;//函數回傳,解析完畢,彈棧</span></span><br><span class="line"><span class="string">        id = sym; //恢復全域變數的訊息</span></span><br><span class="line"><span class="string">        while (id[Tk]) &#123;</span></span><br><span class="line"><span class="string">//恢復符號訊息</span></span><br><span class="line"><span class="string">          if (id[Class] == Loc) &#123;</span></span><br><span class="line"><span class="string">            id[Class] = id[HClass];</span></span><br><span class="line"><span class="string">            id[Type] = id[HType];</span></span><br><span class="line"><span class="string">            id[Val] = id[HVal];</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          id = id + Idsz;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      else &#123;</span></span><br><span class="line"><span class="string">        id[Class] = Glo;//全域變數</span></span><br><span class="line"><span class="string">        id[Val] = (int)data;//給全域變數在data段分配內存</span></span><br><span class="line"><span class="string">        data = data + sizeof(int);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      if (tk == &#x27;,&#x27;) next();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    next();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (!(pc = (int *)idmain[Val])) &#123; printf(&quot;</span>main() not defined\n<span class="string">&quot;); return -1; &#125;</span></span><br><span class="line"><span class="string">  if (src) return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 設定堆疊</span></span><br><span class="line"><span class="string">  sp = (int *)((int)sp + poolsz);</span></span><br><span class="line"><span class="string">  *--sp = EXIT; // 如果main回傳則呼叫exit</span></span><br><span class="line"><span class="string">  *--sp = PSH; t = sp;</span></span><br><span class="line"><span class="string">  *--sp = argc;</span></span><br><span class="line"><span class="string">  *--sp = (int)argv;</span></span><br><span class="line"><span class="string">  *--sp = (int)t;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // run...</span></span><br><span class="line"><span class="string">  cycle = 0;</span></span><br><span class="line"><span class="string">  while (1) &#123;</span></span><br><span class="line"><span class="string">    i = *pc++; ++cycle;</span></span><br><span class="line"><span class="string">    if (debug) &#123;</span></span><br><span class="line"><span class="string">//運算</span></span><br><span class="line"><span class="string">      printf(&quot;</span>%d&gt; %.<span class="number">4</span>s<span class="string">&quot;, cycle,</span></span><br><span class="line"><span class="string">        &amp;&quot;</span>LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,<span class="string">&quot;</span></span><br><span class="line"><span class="string">         &quot;</span>OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,<span class="string">&quot;</span></span><br><span class="line"><span class="string">         &quot;</span>OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,<span class="string">&quot;[i * 5]);</span></span><br><span class="line"><span class="string">      if (i &lt;= ADJ) printf(&quot;</span> %d\n<span class="string">&quot;, *pc); else printf(&quot;</span>\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//記憶體結構</span></span><br><span class="line"><span class="string">    if      (i == LEA) a = (int)(bp + *pc++);                             // load local address</span></span><br><span class="line"><span class="string">    else if (i == IMM) a = *pc++;                                         // load global address or immediate</span></span><br><span class="line"><span class="string">    else if (i == JMP) pc = (int *)*pc;                                   // jump</span></span><br><span class="line"><span class="string">    else if (i == JSR) &#123; *--sp = (int)(pc + 1); pc = (int *)*pc; &#125;        // jump to subroutine</span></span><br><span class="line"><span class="string">    else if (i == BZ)  pc = a ? pc + 1 : (int *)*pc;                      // branch if zero</span></span><br><span class="line"><span class="string">    else if (i == BNZ) pc = a ? (int *)*pc : pc + 1;                      // branch if not zero</span></span><br><span class="line"><span class="string">    else if (i == ENT) &#123; *--sp = (int)bp; bp = sp; sp = sp - *pc++; &#125;     // enter subroutine</span></span><br><span class="line"><span class="string">    else if (i == ADJ) sp = sp + *pc++;                                   // stack adjust</span></span><br><span class="line"><span class="string">    else if (i == LEV) &#123; sp = bp; bp = (int *)*sp++; pc = (int *)*sp++; &#125; // leave subroutine</span></span><br><span class="line"><span class="string">    else if (i == LI)  a = *(int *)a;                                     // load int</span></span><br><span class="line"><span class="string">    else if (i == LC)  a = *(char *)a;                                    // load char</span></span><br><span class="line"><span class="string">    else if (i == SI)  *(int *)*sp++ = a;                                 // store int</span></span><br><span class="line"><span class="string">    else if (i == SC)  a = *(char *)*sp++ = a;                            // store char</span></span><br><span class="line"><span class="string">    else if (i == PSH) *--sp = a;                                         // push</span></span><br><span class="line"><span class="string">//執行流程</span></span><br><span class="line"><span class="string">    else if (i == OR)  a = *sp++ |  a;</span></span><br><span class="line"><span class="string">    else if (i == XOR) a = *sp++ ^  a;</span></span><br><span class="line"><span class="string">    else if (i == AND) a = *sp++ &amp;  a;</span></span><br><span class="line"><span class="string">    else if (i == EQ)  a = *sp++ == a;</span></span><br><span class="line"><span class="string">    else if (i == NE)  a = *sp++ != a;</span></span><br><span class="line"><span class="string">    else if (i == LT)  a = *sp++ &lt;  a;</span></span><br><span class="line"><span class="string">    else if (i == GT)  a = *sp++ &gt;  a;</span></span><br><span class="line"><span class="string">    else if (i == LE)  a = *sp++ &lt;= a;</span></span><br><span class="line"><span class="string">    else if (i == GE)  a = *sp++ &gt;= a;</span></span><br><span class="line"><span class="string">    else if (i == SHL) a = *sp++ &lt;&lt; a;</span></span><br><span class="line"><span class="string">    else if (i == SHR) a = *sp++ &gt;&gt; a;</span></span><br><span class="line"><span class="string">    else if (i == ADD) a = *sp++ +  a;</span></span><br><span class="line"><span class="string">    else if (i == SUB) a = *sp++ -  a;</span></span><br><span class="line"><span class="string">    else if (i == MUL) a = *sp++ *  a;</span></span><br><span class="line"><span class="string">    else if (i == DIV) a = *sp++ /  a;</span></span><br><span class="line"><span class="string">    else if (i == MOD) a = *sp++ %  a;</span></span><br><span class="line"><span class="string">//輸入輸出函數，包括了檔案讀寫、螢幕輸出等函數</span></span><br><span class="line"><span class="string">    else if (i == OPEN) a = open((char *)sp[1], *sp);</span></span><br><span class="line"><span class="string">    else if (i == READ) a = read(sp[2], (char *)sp[1], *sp);</span></span><br><span class="line"><span class="string">    else if (i == CLOS) a = close(*sp);</span></span><br><span class="line"><span class="string">    else if (i == PRTF) &#123; t = sp + pc[1]; a = printf((char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); &#125;</span></span><br><span class="line"><span class="string">    else if (i == MALC) a = (int)malloc(*sp);</span></span><br><span class="line"><span class="string">    else if (i == FREE) free((void *)*sp);</span></span><br><span class="line"><span class="string">    else if (i == MSET) a = (int)memset((char *)sp[2], sp[1], *sp);</span></span><br><span class="line"><span class="string">    else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp);</span></span><br><span class="line"><span class="string">    else if (i == EXIT) &#123; printf(&quot;</span><span class="built_in">exit</span>(%d) cycle = %d\n<span class="string">&quot;, *sp, cycle); return *sp; &#125;</span></span><br><span class="line"><span class="string">    else &#123; printf(&quot;</span>unknown instruction = %d! cycle = %d\n<span class="string">&quot;, i, cycle); return -1; &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>它具備完整的詞法分析、語法分析、簡單的語意檢查、程式碼產生、執行環境（即虛擬機器）。</p>
<p>與常見的C編譯器不同的是，它把C語言原始程式編譯成字節碼（bytecode），然後在一個精簡的虛擬機器中解釋執行。</p>
<p>C4特別的地方就是可以自己編譯自己</p>
<p>先用GCC把C4編譯成執行檔：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc c4.c -o c4</span><br></pre></td></tr></table></figure>
<p>執行「Hello, World!」測試程式hello.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="img/c4_1.png" alt="Untitled"></p>
<p>「hello, world」是hello.c 輸出的，「exit(0) cycle = 9」是c4編譯器輸出的，表示程式正常運作結束，hello.c一共產生9個指令。</p>
<p>用GCC編譯c4.c產生了可執行檔c4，稱為編譯器A，然後用編譯器A來編譯c4的源碼c4.c，則產生一個編譯器B，然後再用編譯器B來編譯執行hello.c。</p>
<p><img src="img/c4_2.png" alt="Untitled"></p>
<p>命令如下：</p>
<p>./c4 c4.c hello.c</p>
<p><img src="img/c4_3.png" alt="Untitled"></p>
<p>理論上可以一直遞歸下去。遞歸的層次越深，產生的字節碼越多，執行所需的時間也越多。</p>
<p>C4實作的C語言子集<br>C4致力於用最少的程式碼，實作一個可以自舉的C編譯器。它的整個實作只有4個函數組成，可想而知，它不可能完整的實作整個C語言的規範，它只實作了C語言的一個子集。</p>
<h3 id="資料類型"><a href="#資料類型" class="headerlink" title="資料類型"></a>資料類型</h3><ul>
<li>char</li>
<li>int</li>
<li>指針</li>
<li>列舉（enum）</li>
<li>陣列</li>
<li>字串</li>
<li>不支援struct、typedef、union等資料類型。</li>
</ul>
<h3 id="語句結構"><a href="#語句結構" class="headerlink" title="語句結構"></a>語句結構</h3><ul>
<li>if-else控制語句</li>
<li>while迴圈語句</li>
<li>return語句</li>
<li>函數</li>
<li>不支援do-while、switch-case、for、continue、break、goto等語句結構。</li>
</ul>
<h3 id="運算符"><a href="#運算符" class="headerlink" title="運算符"></a>運算符</h3><p>它支援除+=、%=、&lt;&lt;=、&amp;=等符合運算子之外的幾乎所有運算子。包括：</p>
<ul>
<li>算術運算符</li>
<li>關係運算符</li>
<li>邏輯運算符</li>
<li>位元運算符</li>
<li>賦值運算符</li>
<li>雜項運算子（如三元運算子?:）</li>
<li><p>內建庫函數</p>
</li>
<li><p>Virtual Machine (c4)</p>
<ul>
<li>sp：stack frame。</li>
<li>a：register 暫存器。</li>
<li>bp：概念跟 rbp(32 bits)/ebp(64 bits) 相同。</li>
<li>pc：program counter，指向當前指令。</li>
<li>instuction：OPCODE。</li>
</ul>
</li>
</ul>
<h3 id="內建庫函數"><a href="#內建庫函數" class="headerlink" title="內建庫函數"></a>內建庫函數</h3><p>C4編譯器實作時用到了一些系統函式庫函數，因此，為了實現自舉，它也內建支援了幾個函式庫函數。包括：</p>
<p>open、read、close、printf、malloc、free、memset、memcmp、exit<br>需要注意的是，它不支援以#開頭的預處理命令，如#include、#define、#if等。</p>
<p>程式碼註釋只支援「//」開頭的單行註釋，不支援「/<em> </em>/」標記的多行註解形式。</p>
<p>與傳統的C語言編譯器相比，C4在實作上有其獨到之處。</p>
<p>下面，先簡單介紹一些傳統編譯器的實作過程。</p>
<h3 id="傳統典型編譯器的實現"><a href="#傳統典型編譯器的實現" class="headerlink" title="傳統典型編譯器的實現"></a>傳統典型編譯器的實現</h3><p>典型的編譯器的實現，通常都會有下面幾個過程：</p>
<ul>
<li>詞法分析</li>
<li>語法分析</li>
<li>語意分析</li>
<li>中間程式碼生成</li>
<li>程式碼最佳化</li>
<li>機器碼生成</li>
<li>如GCC、Clang….</li>
</ul>
<p><img src="img/c4_4.png" alt="Untitled"></p>
<p>這些階段，會對程式碼進行多次掃描。這裡的程式碼，包括文字形式的原始碼、語法樹、中間程式碼等表示形式。</p>
<p>在典型的實作中，詞法分析和語法分析通常會糅合在一起，在語法分析時，呼叫詞法分析器逐一取得token。因此，理論上講，詞法分析和語法分析階段，只需要對源碼掃描一遍即可，並生成語法樹，有時也叫抽象語法樹（Abstract Syntax Tree）。</p>
<p>語意分析階段操作的主要物件就是這棵樹，至少要對這棵樹掃描一次。有些實作中，在進行語意檢查的同時也會直接產生中間程式碼。</p>
<p>在程式碼最佳化階段，根據編譯器最佳化的力度的不同，可能會對中間程式碼進行多次掃描。</p>
<p>這裡所謂的“掃描一遍”，在編譯器術語中一般稱為pass。對LLVM有了解的朋友應該知道，LLVM中每一種類型的最佳化都是一個pass，要應用多種最佳化技術，就需要有多個pass。</p>
<h3 id="程式流程"><a href="#程式流程" class="headerlink" title="程式流程"></a>程式流程</h3><p>總結這個程式的流程﻿ 1. 詞法分析器：</p>
<ul>
<li>忽略空白字元</li>
<li>識別符號、關鍵字、運算符、常數、字串等</li>
<li>將識別符號雜湊並儲存在符號表中</li>
</ul>
<ol>
<li><p>語法分析器：</p>
<ul>
<li>遞迴下降解析器</li>
<li>處理表達式、語句和函數定義</li>
<li>產生中間代碼（IR → Instruction register）</li>
</ul>
</li>
<li><p>IR 優化器：</p>
<ul>
<li>進行常數摺疊、公共子表達式消除等優化</li>
</ul>
</li>
<li><p>程式碼生成器：</p>
<ul>
<li>將 IR 轉換為目標機器碼</li>
</ul>
</li>
<li><p>虛擬機：</p>
<ul>
<li>模擬目標機器執行機器碼</li>
<li>提供除錯功能</li>
</ul>
</li>
</ol>
<h3 id="解析程式流程"><a href="#解析程式流程" class="headerlink" title="解析程式流程"></a><strong>解析程式流程</strong></h3><ol>
<li><strong>詞法分析</strong>：將原始碼切割成一個個的 token，並賦予其對應的 token number。</li>
</ol>
<ul>
<li>詞法分析器會逐個字元地掃描原始碼，並將字元組合成 token。</li>
<li>token 是原始碼中具有特定意義的字元序列，例如關鍵字、識別符號、運算符、分隔符等。</li>
<li>詞法分析器會將 token 分配給對應的 token number，以便後續的語法分析和語義分析。</li>
</ul>
<ol>
<li><strong>語法分析</strong>：將 token 組合起來，形成語法樹。</li>
</ol>
<ul>
<li>語法分析器會根據當前的 token 和語法規則，決定如何將 token 組合起來形成語法樹。</li>
<li>語法樹是一種樹狀結構，它表示原始碼的語法結構。</li>
<li>語法分析器會檢查語法樹是否符合語法規則，如果發現語法錯誤，則會報錯。</li>
</ul>
<ol>
<li><strong>語義分析</strong>：檢查語法樹是否符合語法規則，並產生對應的 IR (Intermediate Representation) 指令。</li>
</ol>
<ul>
<li>語義分析器會檢查語法樹是否符合語法規則，並產生對應的 IR 指令。</li>
<li>IR 指令是一種中間表示，它比機器碼更接近原始碼，但又比原始碼更接近機器碼。</li>
<li>IR 指令可以被編譯器轉換成機器碼。</li>
</ul>
<ol>
<li><strong>程式碼生成</strong>：將 IR 指令轉換成機器碼。</li>
</ol>
<ul>
<li>程式碼生成器會將 IR 指令轉換成機器碼。</li>
<li>機器碼是電腦可以直接執行的指令。</li>
</ul>
<ol>
<li><strong>執行</strong>：將機器碼載入到記憶體中，並執行。</li>
</ol>
<ul>
<li>執行器會將機器碼載入到記憶體中，並執行。</li>
<li>電腦會根據機器碼的指令，一步一步地執行程式。</li>
</ul>
<p>在這個專案程式中，詞法分析、語法分析、語義分析和代碼生成都是由同一個程式來完成的。</p>
<p>這個程式會逐行讀取原始碼，並將原始碼轉換成機器碼。然後，程式會將機器碼載入到記憶體中，並執行。</p>
<h3 id="C4的獨具特色之處"><a href="#C4的獨具特色之處" class="headerlink" title="C4的獨具特色之處"></a>C4的獨具特色之處</h3><p>作為追求極簡主義的C4編譯器來說，它在實作上有許多獨具特色之處。</p>
<h3 id="對C源碼解釋執行"><a href="#對C源碼解釋執行" class="headerlink" title="對C源碼解釋執行"></a>對C源碼解釋執行</h3><p>傳統的C語言編譯器，最後都把C語言原始碼編譯成可執行文件，也就是二進位的機器碼。</p>
<p>而C4則是把C語言原始碼先編譯成其專門設計的字節碼（bytecode），然後直接在虛擬機器中解釋執行。</p>
<p>C4設計了39個字節碼指令，其中大部分與彙編語言中的指令有些類似，主要是記憶體載入指令，算術運算指令等，此外，還包含了為支援內建的函式庫函數而專門設計的9條特殊的函式庫函數呼叫指令。</p>
<p>它的虛擬機是典型的堆疊式虛擬機（Java虛擬機也是典型的堆疊式虛擬機，早期的Lua也是棧式虛擬機，但最新的Lua 5.x採用暫存器虛擬機）。</p>
<p>可以使用-d指令，把產生的字節碼dump出來。下圖是hello.c的字節碼：</p>
<p><img src="img/c4_5.png" alt="Untitled"></p>
<p><strong>對源碼只掃描一遍</strong></p>
<p>與傳統的編譯器實作不同，C4它把詞法分析、語法分析、語意分析、程式碼產生這幾個步驟巧妙的結合在一起，在把C語言源碼編譯成字節碼的整個過程中，只掃描了一遍源碼。</p>
<p>Lua的解釋器也是採用對原始碼掃描一遍的方式，因此，C4和Lua的表現都相當不錯。</p>
<h3 id="C4原始碼的可讀性"><a href="#C4原始碼的可讀性" class="headerlink" title="C4原始碼的可讀性"></a><strong>C4原始碼的可讀性</strong></h3><p>C4的實作非常簡潔，畢竟只有4個函數，500多行程式碼。但是要真正完全理解，需要有一定的編譯原理基礎知識。</p>
<p>例如C4的語法分析過程中，就是<strong>典型的遞歸下降和算子優先演算法結合</strong>的實作方式。只要了解這些編譯器的經典演算法原理，C4的實作邏輯理解起來，還是比較輕鬆的。</p>
<p>C4不支援struct類型。這也意味著C4的源碼中不能使用struct型別。為此，它選擇<strong>使用陣列</strong>來模擬struct結構。這樣乍看，可能會產生一些困惑。</p>
<p>C4的一個槽點，就是它變數的命名上，過於簡潔。例如標記字節碼的位置的變數用e表示，其實如果用emit的話，就會清晰許多，也會更容易理解。</p>
<h3 id="C4的衍生實現"><a href="#C4的衍生實現" class="headerlink" title="C4的衍生實現"></a>C4的衍生實現</h3><p>除了C4的原生實作外，網路上也有很多基於C4的衍生實作。</p>
<p>例如有人為C4額外增加了80多行程式碼，卻為C4增加了JIT功能，使得執行速度明顯提升。</p>
<p>也有人對C4做了簡單修改，使得它可以直接產生真實的機器碼，最後產生ELF執行檔。</p>
<h3 id="Virtual-Machine-Opcode"><a href="#Virtual-Machine-Opcode" class="headerlink" title="Virtual Machine (Opcode)"></a><strong>Virtual Machine (Opcode)</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// opcodes</span><br><span class="line">enum &#123; LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,</span><br><span class="line">       OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,</span><br><span class="line">       OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/pcp5DfL.png" alt="https://i.imgur.com/pcp5DfL.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Opcode</th>
<th>Fully Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>LEA</td>
<td>Load Effective Address</td>
<td>利用 bp 將相對位址存入暫存器 a</td>
</tr>
<tr>
<td>IMM</td>
<td>Immediate Value</td>
<td>將 immediate value or global address 存入暫存器 a</td>
</tr>
<tr>
<td>JMP</td>
<td>Jump</td>
<td>跳轉至目標指令的絕對位址</td>
</tr>
<tr>
<td>JSR</td>
<td>Jump to SubRoutine</td>
<td>Push return address into sp and JMP</td>
</tr>
<tr>
<td>BZ</td>
<td>Branch if Zero</td>
<td>後面接的是目標指令的絕對位址</td>
</tr>
<tr>
<td>BNZ</td>
<td>Branch if NOT Zero</td>
<td>後面接的是目標指令的絕對位址</td>
</tr>
<tr>
<td>ENT</td>
<td>Enter SubRoutine</td>
<td>Push bp and bp points to sp，sp 會預留 local variables 的位置</td>
</tr>
<tr>
<td>ADJ</td>
<td>Stack Adjust</td>
<td>根據目前 sp 的相對位置</td>
</tr>
<tr>
<td>LEV</td>
<td>Leave SubRoutine</td>
<td>sp=bp, bp points to old bp, 讀取 return address to pc, sp++釋放空間</td>
</tr>
<tr>
<td>LI</td>
<td>Load INT</td>
<td>將暫存器 a 所指的位址取值，存入暫存器 a</td>
</tr>
<tr>
<td>LC</td>
<td>Load CHAR</td>
<td>將暫存器 a 所指的位址取值，存入暫存器 a</td>
</tr>
<tr>
<td>SI</td>
<td>Store INT</td>
<td>將暫存器 a 取值，存入 stack frame sp 所指的位址，然後 sp++</td>
</tr>
<tr>
<td>SC</td>
<td>Store CHAR</td>
<td>將暫存器 a 取值，存入 stack frame sp 所指的位址，然後 sp++，最後再存入暫存器 a</td>
</tr>
<tr>
<td>PSH</td>
<td>Push into Stack Frame</td>
<td>將暫存器 a 的值 push into Stack Frame</td>
</tr>
<tr>
<td>OR-MODE</td>
<td>Arithmetic operation</td>
<td>pop from Stack Frame and calculate with register value, and then restore into regrister.</td>
</tr>
<tr>
<td>OPEN-MEMCMP</td>
<td>System Call</td>
<td>使用 Stack Frame sp 當作參數傳遞，並且 pop Stack</td>
</tr>
<tr>
<td>EXIT</td>
<td>exit program</td>
<td>利用 Stack Frame sp 當作回傳值</td>
</tr>
</tbody>
</table>
</div>
<p>• c4 在 <code>next()</code> Lexical analyzer 的時候就有包含 semantic analyzer，這時候會建立 symbol table；在 <code>main()</code> 會檢查是否重複定義；在 <code>expr()</code> 會做 type checking and undefined variable checking，這些部分也是屬於 semantic analyzer。</p>
<h3 id="stmt"><a href="#stmt" class="headerlink" title="stmt()"></a><strong>stmt()</strong></h3><p>利用 recursive-descent 處理 “if-else”, “while”, “return”, “{}”, “;”。這部分的 source code 非常直觀</p>
<p>其他參考資料</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lotabout/write-a-C-interpreter">https://github.com/lotabout/write-a-C-interpreter</a></p>
<p><a target="_blank" rel="noopener" href="https://hackmd.io/@srhuang/Bkk2eY5ES#main--declaration">https://hackmd.io/@srhuang/Bkk2eY5ES#main—declaration</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/rswier/c4/blob/master/c4.c">https://github.com/rswier/c4/blob/master/c4.c</a></p>
<p><strong>特點：</strong></p>
<ul>
<li>簡單：僅用500餘行程式碼就實現了一個c編譯器。</li>
<li>類似解釋器：實現了自己的虛擬機器指令集，直接產生為目標程式碼，忽略中間程式碼的過程。</li>
<li>自舉：可以自己編譯自己。</li>
<li>只能在32位元環境下跑。</li>
<li>單趟編譯器：分析過程只有一遍。</li>
<li>語法分析屬於自頂向下分析法，表達式分析採了比較流行的用遞歸下降和運算子優先級方法結合的方式。</li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li>c4編譯器是一個非常簡單的編譯器，但它實現了編譯器的基本原理，是一個很好的學習資源。</li>
<li>c4編譯器類似於解釋器，它直接產生為目標程式碼，忽略中間程式碼的過程。這使得它比傳統的編譯器更簡單，但執行速度也更慢。</li>
<li>c4編譯器可以自己編譯自己，這是一個非常強大的功能。它意味著c4編譯器可以移植到任何支援C語言的平臺上。</li>
<li>c4編譯器是單趟編譯器，這意味著它在遍歷原始程式碼時只會分析一遍。這使得c4編譯器非常快，但它也意味著c4編譯器不能檢測出所有的錯誤。</li>
<li>c4編譯器的語法分析屬於自頂向下分析法，表達式分析採了比較流行的用遞歸下降和運算子優先級方法結合的方式。這使得c4編譯器的語法分析非常高效。</li>
</ul>
<p><strong>總結：</strong></p>
<p>c4編譯器是一個非常簡單、強大且高效的編譯器。它是一個很好的學習資源，也非常適合用於移植到其他平臺上。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/12/21/Capstone-Privilege/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Privilege Escalation
        
      </div>
    </a>
  
  
    <a href="/2024/12/21/Brainfuck/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">HTB_Brainfuck</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 Noflag
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>