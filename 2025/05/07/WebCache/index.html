<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Web Cache Deception | HackThe4O4</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Web Cache Deception簡介 &#x2F; IntroductionWeb Cache Deception（網頁快取欺騙）是一種安全漏洞，允許攻擊者誘導 web cache（網頁快取）錯誤地儲存敏感的 dynamic content（動態內容），例如用戶的個人資料或帳戶資訊。這種漏洞源於 cache server（快取伺服器）和 origin server（原始伺服器）在處理 HTT">
<meta property="og:type" content="article">
<meta property="og:title" content="Web Cache Deception">
<meta property="og:url" content="https://no-flag.com/2025/05/07/WebCache/index.html">
<meta property="og:site_name" content="HackThe4O4">
<meta property="og:description" content="Web Cache Deception簡介 &#x2F; IntroductionWeb Cache Deception（網頁快取欺騙）是一種安全漏洞，允許攻擊者誘導 web cache（網頁快取）錯誤地儲存敏感的 dynamic content（動態內容），例如用戶的個人資料或帳戶資訊。這種漏洞源於 cache server（快取伺服器）和 origin server（原始伺服器）在處理 HTT">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-06T17:09:04.106Z">
<meta property="article:modified_time" content="2025-05-06T17:11:14.236Z">
<meta property="article:author" content="Noflag">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="HackThe4O4" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/cat.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  


<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/mela.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/2024/12/21/hello-world/">About Me</a></li>
				        
							<li><a href="/archives">All articles</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/mela.gif" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/2024/12/21/hello-world/">About Me</a></li>
		        
					<li><a href="/archives">All articles</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="Web Cache Deception-WebCache" class="article article-type-Web Cache Deception" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/07/WebCache/" class="article-date">
  	<time datetime="2025-05-06T17:09:04.106Z" itemprop="datePublished">2025-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Web Cache Deception
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Web-Cache-Deception"><a href="#Web-Cache-Deception" class="headerlink" title="Web Cache Deception"></a>Web Cache Deception</h1><h2 id="簡介-Introduction"><a href="#簡介-Introduction" class="headerlink" title="簡介 &#x2F; Introduction"></a>簡介 &#x2F; Introduction</h2><p><strong>Web Cache Deception</strong>（網頁快取欺騙）是一種安全漏洞，允許攻擊者誘導 <strong>web cache</strong>（網頁快取）錯誤地儲存敏感的 <strong>dynamic content</strong>（動態內容），例如用戶的個人資料或帳戶資訊。這種漏洞源於 <strong>cache server</strong>（快取伺服器）和 <strong>origin server</strong>（原始伺服器）在處理 <strong>HTTP requests</strong>（HTTP 請求）時的行為差異。攻擊者通過精心設計的 <strong>URL</strong>，誘騙受害者訪問，從而讓 <strong>cache</strong> 儲存敏感資料，之後攻擊者可直接從 <strong>cache</strong> 獲取這些資料，實現 <strong>unauthorized access</strong>（未授權訪問）。</p>
<p><strong>白話解釋</strong>：<br>想像 <strong>web cache</strong> 是一個圖書館的快取櫃檯，負責快速提供常用書籍（<strong>static resources</strong>，靜態資源）。但如果有人騙櫃檯把機密文件（<strong>dynamic content</strong>）當成普通書籍儲存，壞人就可以輕鬆拿到這些文件。這就是 <strong>Web Cache Deception</strong>。</p>
<hr>
<h2 id="Web-Cache-的基礎-Basics-of-Web-Cache"><a href="#Web-Cache-的基礎-Basics-of-Web-Cache" class="headerlink" title="Web Cache 的基礎 &#x2F; Basics of Web Cache"></a>Web Cache 的基礎 &#x2F; Basics of Web Cache</h2><h3 id="什麼是-Web-Cache？-What-is-a-Web-Cache"><a href="#什麼是-Web-Cache？-What-is-a-Web-Cache" class="headerlink" title="什麼是 Web Cache？ &#x2F; What is a Web Cache?"></a>什麼是 Web Cache？ &#x2F; What is a Web Cache?</h3><p><strong>Web Cache</strong>（網頁快取）是一個中介系統，位於 <strong>client</strong>（客戶端，如瀏覽器）和 <strong>origin server</strong>（原始伺服器，儲存網站內容的伺服器）之間。它儲存網站的 <strong>static resources</strong>（靜態資源，如圖片、<strong>CSS</strong> 檔案或 <strong>JavaScript</strong> 檔案），以加快網頁載入速度並減少 <strong>origin server</strong> 的負載。</p>
<p><strong>工作原理</strong>：<br>當 <strong>client</strong> 發送 <strong>HTTP request</strong> 請求 <strong>static resource</strong> 時：</p>
<ol>
<li>請求首先到達 <strong>cache server</strong>。</li>
<li>如果 <strong>cache</strong> 已有資源副本（稱為 <strong>cache hit</strong>，快取命中），則直接返回給 <strong>client</strong>。</li>
<li>如果 <strong>cache</strong> 沒有副本（稱為 <strong>cache miss</strong>，快取未命中），則將請求轉發至 <strong>origin server</strong>，獲取回應後儲存至 <strong>cache</strong>，再返回給 <strong>client</strong>。</li>
</ol>
<p><strong>白話解釋</strong>：<br><strong>Web Cache</strong> 就像圖書館的快取櫃檯，儲存常用的書（<strong>static resources</strong>），讓讀者（<strong>client</strong>）不用每次都去書庫（<strong>origin server</strong>）找書。如果櫃檯有書（<strong>cache hit</strong>），馬上給你；如果沒有（<strong>cache miss</strong>），就去書庫拿，然後存一份在櫃檯。</p>
<h3 id="Web-Cache-的關鍵組件-Key-Components-of-Web-Cache"><a href="#Web-Cache-的關鍵組件-Key-Components-of-Web-Cache" class="headerlink" title="Web Cache 的關鍵組件 &#x2F; Key Components of Web Cache"></a>Web Cache 的關鍵組件 &#x2F; Key Components of Web Cache</h3><ol>
<li><p><strong>Cache Key</strong>（快取鍵）：<br><strong>Cache server</strong> 用來識別和匹配 <strong>HTTP request</strong> 的標識，通常由 <strong>URL path</strong>（URL 路徑）、<strong>query parameters</strong>（查詢參數）和其他 <strong>HTTP headers</strong>（HTTP 標頭，如 <strong>Accept</strong> 或 <strong>Content-Type</strong>）組成。如果兩個請求的 <strong>cache key</strong> 相同，<strong>cache</strong> 認為它們請求相同的資源。</p>
</li>
<li><p><strong>Cache Rules</strong>（快取規則）：<br>定義哪些資源可以儲存、儲存多久。常見規則包括：</p>
<ul>
<li><strong>Static File Extension Rules</strong>（靜態檔案副檔名規則）：匹配如 <code>.css</code>、<code>.js</code> 的檔案。</li>
<li><strong>Static Directory Rules</strong>（靜態目錄規則）：匹配特定目錄，如 <code>/static</code> 或 <code>/assets</code>。</li>
<li><strong>File Name Rules</strong>（檔案名稱規則）：匹配特定檔案，如 <code>robots.txt</code> 或 <code>favicon.ico</code>。</li>
</ul>
</li>
<li><p><strong>Cache-Control Headers</strong>（快取控制標頭）：<br><strong>HTTP headers</strong> 用於指示 <strong>cache</strong> 如何處理回應。例如：</p>
<ul>
<li><code>Cache-Control: public, max-age=3600</code>：表示資源可公開快取 1 小時。</li>
<li><code>Cache-Control: no-store</code>：禁止快取。</li>
<li><code>Cache-Control: private</code>：僅限 <strong>client</strong> 快取，不允許 <strong>cache server</strong> 儲存。</li>
</ul>
</li>
<li><p>**Content Delivery Network (CDN)**（內容傳遞網路）：<br>一種分佈式 <strong>cache server</strong> 網路，將 <strong>static resources</strong> 儲存在全球各地的伺服器，根據用戶位置提供最快的回應。常見 <strong>CDN</strong> 包括 <strong>Cloudflare</strong> 和 <strong>Akamai</strong>。</p>
</li>
</ol>
<p><strong>白話解釋</strong>：<br><strong>Cache Key</strong> 像書的編號，櫃檯用它找書。<strong>Cache Rules</strong> 是櫃檯的儲存規則，比如只存雜誌（<code>.css</code>）。<strong>Cache-Control Headers</strong> 是書上的標籤，告訴櫃檯能不能存這本書。<strong>CDN</strong> 像是遍佈全球的圖書館分館，讓你拿書更快。</p>
<h3 id="Web-Cache-Deception-與-Web-Cache-Poisoning-的區別-Difference-Between-Web-Cache-Deception-and-Web-Cache-Poisoning"><a href="#Web-Cache-Deception-與-Web-Cache-Poisoning-的區別-Difference-Between-Web-Cache-Deception-and-Web-Cache-Poisoning" class="headerlink" title="Web Cache Deception 與 Web Cache Poisoning 的區別 &#x2F; Difference Between Web Cache Deception and Web Cache Poisoning"></a>Web Cache Deception 與 Web Cache Poisoning 的區別 &#x2F; Difference Between Web Cache Deception and Web Cache Poisoning</h3><ul>
<li><p><strong>Web Cache Deception</strong>：<br>攻擊者誘導 <strong>cache</strong> 將 <strong>dynamic content</strong>（如用戶資料）誤認為 <strong>static resource</strong> 並儲存，之後攻擊者可直接訪問快取的敏感資料。</p>
</li>
<li><p><strong>Web Cache Poisoning</strong>（網頁快取毒化）：<br>攻擊者操縱 <strong>cache key</strong>，將惡意內容（如 <strong>JavaScript</strong> 攻擊腳本）注入快取，影響所有訪問該快取的用戶。</p>
</li>
</ul>
<p><strong>白話解釋</strong>：<br><strong>Web Cache Deception</strong> 是騙櫃檯把機密文件當普通書存起來，壞人自己去拿。<strong>Web Cache Poisoning</strong> 是把一本帶病毒的書放進櫃檯，害每個借書的人都中毒。</p>
<hr>
<h2 id="統一情境：ShopEasy-電商網站的-Web-Cache-系統-Unified-Scenario-ShopEasy-E-commerce-Website"><a href="#統一情境：ShopEasy-電商網站的-Web-Cache-系統-Unified-Scenario-ShopEasy-E-commerce-Website" class="headerlink" title="統一情境：ShopEasy 電商網站的 Web Cache 系統 &#x2F; Unified Scenario: ShopEasy E-commerce Website"></a>統一情境：ShopEasy 電商網站的 Web Cache 系統 &#x2F; Unified Scenario: ShopEasy E-commerce Website</h2><p>為了讓攻擊手法更具體，我們設定一個情境：ShopEasy 是一家電商網站，使用 <strong>CDN</strong>（如 <strong>Cloudflare</strong>）提供 <strong>web cache</strong> 服務，加速 <strong>static resources</strong>（如產品圖片、<strong>CSS</strong> 檔案）載入。網站包含以下功能：</p>
<ul>
<li><strong>User Profile</strong>（用戶檔案）：顯示用戶的個人資料（如電子郵件、訂單歷史）。</li>
<li><strong>Order History</strong>（訂單歷史）：列出用戶的購買記錄。</li>
<li><strong>Product Pages</strong>（產品頁面）：包含靜態資源（如 <code>/assets/images/product.jpg</code>）和動態內容（如用戶評論）。</li>
<li><strong>APIs</strong>：提供動態資料，如 <code>/api/user/profile</code> 返回用戶資訊。</li>
</ul>
<p>ShopEasy 的 <strong>cache server</strong> 設定了以下 <strong>cache rules</strong>：</p>
<ul>
<li>儲存副檔名為 <code>.css</code>、<code>.js</code>、<code>.jpg</code> 的資源。</li>
<li>儲存位於 <code>/static</code> 和 <code>/assets</code> 目錄的資源。</li>
<li>儲存特定檔案，如 <code>robots.txt</code> 和 <code>favicon.ico</code>。</li>
<li>忽略 <strong>Cache-Control: no-store</strong> 的動態資源（配置錯誤）。</li>
</ul>
<p><strong>漏洞</strong>：</p>
<ul>
<li><strong>Cache server</strong> 和 <strong>origin server</strong> 在解析 <strong>URL path</strong> 時存在差異（如 <strong>delimiter</strong> 或 <strong>normalization</strong>）。</li>
<li>缺乏對 <strong>dynamic content</strong> 的嚴格 <strong>cache-control</strong>。</li>
<li>未啟用 <strong>CDN</strong> 的 <strong>Cache Deception Armor</strong>（快取欺騙防護）。</li>
</ul>
<p>以下將以 ShopEasy 為例，展示所有 <strong>Web Cache Deception</strong> 攻擊手法。</p>
<hr>
<h2 id="Web-Cache-Deception-的攻擊手法-Attack-Techniques-for-Web-Cache-Deception"><a href="#Web-Cache-Deception-的攻擊手法-Attack-Techniques-for-Web-Cache-Deception" class="headerlink" title="Web Cache Deception 的攻擊手法 &#x2F; Attack Techniques for Web Cache Deception"></a>Web Cache Deception 的攻擊手法 &#x2F; Attack Techniques for Web Cache Deception</h2><p><strong>Web Cache Deception</strong> 攻擊利用 <strong>cache server</strong> 和 <strong>origin server</strong> 在處理 <strong>URL path</strong> 時的差異，誘導 <strong>cache</strong> 儲存 <strong>dynamic content</strong>。以下詳細介紹所有攻擊手法，每種包含定義、原理、ShopEasy 情境中的具體攻擊方法、範例和防禦策略。</p>
<h3 id="攻擊手法-1：Exploiting-Static-Extension-Cache-Rules（利用靜態副檔名快取規則）"><a href="#攻擊手法-1：Exploiting-Static-Extension-Cache-Rules（利用靜態副檔名快取規則）" class="headerlink" title="攻擊手法 1：Exploiting Static Extension Cache Rules（利用靜態副檔名快取規則）"></a>攻擊手法 1：Exploiting Static Extension Cache Rules（利用靜態副檔名快取規則）</h3><p><strong>定義</strong>：<br>攻擊者利用 <strong>cache rules</strong> 針對靜態副檔名（如 <code>.css</code>、<code>.js</code>）的特性，構造 <strong>URL</strong> 使 <strong>cache server</strong> 誤認為請求的是 <strong>static resource</strong>，而 <strong>origin server</strong> 返回 <strong>dynamic content</strong>，從而儲存敏感資料。</p>
<p><strong>原理</strong>：<br><strong>Cache server</strong> 根據 <strong>URL</strong> 的副檔名（如 <code>.css</code>）決定是否快取，而 <strong>origin server</strong> 可能忽略副檔名，處理為動態請求。這種 <strong>path mapping discrepancy</strong>（路徑映射差異）導致 <strong>cache</strong> 儲存不該儲存的內容。</p>
<p><strong>ShopEasy 攻擊方法</strong>：<br>攻擊者構造一個 <strong>URL</strong>，誘導受害者（用戶 carlos）訪問，觸發 <strong>cache</strong> 儲存其 <strong>user profile</strong>。</p>
<p><strong>範例</strong>：  </p>
<ol>
<li><p><strong>基本攻擊</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile/wcd.css</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Origin server</strong>（使用 <strong>RESTful URL mapping</strong>）：忽略 <code>wcd.css</code>，解析為 <code>/user/carlos/profile</code>，返回 carlos 的個人資料（<strong>dynamic content</strong>）。</li>
<li><strong>Cache server</strong>（使用 <strong>traditional URL mapping</strong>）：認為這是 <code>/user/carlos/profile/wcd.css</code>，匹配 <code>.css</code> 的 <strong>cache rule</strong>，儲存回應。</li>
<li>攻擊者訪問相同的 <strong>URL</strong>，從 <strong>cache</strong> 獲取 carlos 的資料。</li>
</ul>
</li>
<li><p><strong>多副檔名測試</strong>：<br>攻擊者嘗試不同副檔名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile/wcd.js</span><br><span class="line">https://shopeasy.com/user/carlos/profile/wcd.ico</span><br></pre></td></tr></table></figure>
<p>如果 <strong>cache</strong> 儲存 <code>.ico</code> 的回應，攻擊成功。</p>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>這就像騙櫃檯把 carlos 的機密檔案（<strong>user profile</strong>）當成雜誌（<code>.css</code>）存起來。櫃檯以為是普通書，實際上是機密，壞人後來去拿就拿到了。</p>
<p><strong>防禦</strong>：  </p>
<ul>
<li>使用 <strong>Cache-Control: no-store, private</strong> 標記 <strong>dynamic content</strong>。</li>
<li>確保 <strong>CDN</strong> 驗證 <strong>Content-Type</strong>（內容類型）與副檔名一致（如 <code>.css</code> 應為 <code>text/css</code>）。</li>
<li>啟用 <strong>Cloudflare Cache Deception Armor</strong>。</li>
</ul>
<hr>
<h3 id="攻擊手法-2：Exploiting-Delimiter-Discrepancies（利用分隔符差異）"><a href="#攻擊手法-2：Exploiting-Delimiter-Discrepancies（利用分隔符差異）" class="headerlink" title="攻擊手法 2：Exploiting Delimiter Discrepancies（利用分隔符差異）"></a>攻擊手法 2：Exploiting Delimiter Discrepancies（利用分隔符差異）</h3><p><strong>定義</strong>：<br>攻擊者利用 <strong>cache server</strong> 和 <strong>origin server</strong> 在處理 <strong>delimiter</strong>（分隔符，如 <code>;</code> 或 <code>.</code>）上的差異，構造 <strong>URL</strong> 使 <strong>cache</strong> 儲存 <strong>dynamic content</strong>。</p>
<p><strong>原理</strong>：<br><strong>Delimiter</strong> 是用於分隔 <strong>URL</strong> 元素的字符。不同框架對 <strong>delimiter</strong> 的處理方式不同（如 <strong>Java Spring</strong> 使用 <code>;</code> 作為 <strong>matrix variable</strong> 分隔符），導致 <strong>cache</strong> 和 <strong>origin server</strong> 解析 <strong>URL</strong> 時產生差異。</p>
<p><strong>ShopEasy 攻擊方法</strong>：<br>攻擊者構造包含 <strong>delimiter</strong> 的 <strong>URL</strong>，誘導受害者訪問，觸發 <strong>cache</strong> 儲存敏感資料。</p>
<p><strong>範例</strong>：  </p>
<ol>
<li><p><strong>分號分隔符</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile;wcd.css</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Origin server</strong>（使用 <strong>Java Spring</strong>）：將 <code>;</code> 視為 <strong>delimiter</strong>，解析為 <code>/user/carlos/profile</code>，返回個人資料。</li>
<li><strong>Cache server</strong>（不識別 <code>;</code>）：認為是 <code>/user/carlos/profile;wcd.css</code>，匹配 <code>.css</code> 的 <strong>cache rule</strong>，儲存回應。</li>
<li>攻擊者訪問 <strong>URL</strong>，從 <strong>cache</strong> 獲取資料。</li>
</ul>
</li>
<li><p><strong>點分隔符</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile.ico</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Origin server</strong>（使用 <strong>Ruby on Rails</strong>）：不識別 <code>.ico</code>，解析為 <code>/user/carlos/profile</code>，返回個人資料。</li>
<li><strong>Cache server</strong>：匹配 <code>.ico</code> 的 <strong>cache rule</strong>，儲存回應。</li>
</ul>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>這就像在書名中加一個特殊符號（<code>;</code>），書庫（<strong>origin server</strong>）忽略符號，給你機密文件，但櫃檯（<strong>cache</strong>）以為是雜誌，存起來讓壞人拿。</p>
<p><strong>防禦</strong>：  </p>
<ul>
<li>統一 <strong>cache</strong> 和 <strong>origin server</strong> 的 <strong>delimiter</strong> 處理邏輯。</li>
<li>對 <strong>URL</strong> 進行嚴格 <strong>sanitization</strong>，過濾異常 <strong>delimiter</strong>。</li>
<li>使用 <strong>Burp Intruder</strong> 測試常見 <strong>delimiter</strong>（如 <code>;</code>、<code>.</code>、<code>%00</code>）。</li>
</ul>
<hr>
<h3 id="攻擊手法-3：Exploiting-Delimiter-Decoding-Discrepancies（利用分隔符解碼差異）"><a href="#攻擊手法-3：Exploiting-Delimiter-Decoding-Discrepancies（利用分隔符解碼差異）" class="headerlink" title="攻擊手法 3：Exploiting Delimiter Decoding Discrepancies（利用分隔符解碼差異）"></a>攻擊手法 3：Exploiting Delimiter Decoding Discrepancies（利用分隔符解碼差異）</h3><p><strong>定義</strong>：<br>攻擊者利用 <strong>cache server</strong> 和 <strong>origin server</strong> 在解碼 <strong>URL-encoded</strong>（URL 編碼）分隔符（如 <code>%23</code> 為 <code>#</code>）上的差異，構造 <strong>URL</strong> 使 <strong>cache</strong> 儲存 <strong>dynamic content</strong>。</p>
<p><strong>原理</strong>：<br><strong>URL-encoded</strong> 字符在解析前可能被解碼，影響 <strong>delimiter</strong> 的識別。如果 <strong>cache</strong> 和 <strong>origin server</strong> 的解碼順序或規則不同，可能導致 <strong>path mapping discrepancy</strong>。</p>
<p><strong>ShopEasy 攻擊方法</strong>：<br>攻擊者使用編碼的 <strong>delimiter</strong>，誘導 <strong>cache</strong> 儲存受害者的 <strong>order history</strong>。</p>
<p><strong>範例</strong>：  </p>
<ol>
<li><p><strong>編碼井號</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/api/orders/carlos%23wcd.css</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Origin server</strong>：解碼 <code>%23</code> 為 <code>#</code>，視為 <strong>delimiter</strong>，解析為 <code>/api/orders/carlos</code>，返回訂單歷史。</li>
<li><strong>Cache server</strong>：不解碼 <code>%23</code>，認為是 <code>/api/orders/carlos%23wcd.css</code>，匹配 <code>.css</code> 的 <strong>cache rule</strong>，儲存回應。</li>
<li>攻擊者訪問 <strong>URL</strong>，獲取快取的訂單資料。</li>
</ul>
</li>
<li><p><strong>編碼問號</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/api/orders/carlos%3fwcd.js</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Cache server</strong>：根據編碼路徑 <code>/api/orders/carlos%3fwcd.js</code> 匹配 <code>.js</code> 的 <strong>cache rule</strong>，儲存回應，然後解碼 <code>%3f</code> 為 <code>?</code>，轉發為 <code>/api/orders/carlos?wcd.js</code>。</li>
<li><strong>Origin server</strong>：解析為 <code>/api/orders/carlos</code>，返回訂單歷史。</li>
</ul>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>這就像用密碼（<code>%23</code>）藏一個符號，書庫解開密碼後當成特殊符號處理，給你機密文件，但櫃檯沒解密，以為是普通書，存起來。</p>
<p><strong>防禦</strong>：  </p>
<ul>
<li>統一 <strong>cache</strong> 和 <strong>origin server</strong> 的 <strong>URL decoding</strong>（URL 解碼）邏輯。</li>
<li>測試非可見字符（如 <code>%00</code>、<code>%0A</code>）的解碼行為。</li>
<li>使用 <strong>Cache-Control: no-cache</strong> 防止動態內容被快取。</li>
</ul>
<hr>
<h3 id="攻擊手法-4：Exploiting-Static-Directory-Cache-Rules（利用靜態目錄快取規則）"><a href="#攻擊手法-4：Exploiting-Static-Directory-Cache-Rules（利用靜態目錄快取規則）" class="headerlink" title="攻擊手法 4：Exploiting Static Directory Cache Rules（利用靜態目錄快取規則）"></a>攻擊手法 4：Exploiting Static Directory Cache Rules（利用靜態目錄快取規則）</h3><p><strong>定義</strong>：<br>攻擊者利用 <strong>cache rules</strong> 針對特定目錄（如 <code>/static</code>、<code>/assets</code>）的特性，通過 <strong>path traversal</strong>（路徑穿越）構造 <strong>URL</strong>，使 <strong>cache</strong> 儲存 <strong>dynamic content</strong>。</p>
<p><strong>原理</strong>：<br><strong>Cache server</strong> 可能根據 <strong>URL path</strong> 的前綴（如 <code>/static</code>）快取資源，而 <strong>origin server</strong> 可能通過 <strong>normalization</strong>（路徑標準化）解析 <strong>path traversal</strong>，返回 <strong>dynamic content</strong>。</p>
<p><strong>ShopEasy 攻擊方法</strong>：<br>攻擊者使用 <strong>path traversal</strong>，誘導 <strong>cache</strong> 儲存受害者的 <strong>user profile</strong>。</p>
<p><strong>範例</strong>：  </p>
<ol>
<li><p><strong>標準化差異</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/static/..%2fuser/carlos/profile</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Origin server</strong>：解碼 <code>%2f</code> 為 <code>/</code>，解析為 <code>/user/carlos/profile</code>，返回個人資料。</li>
<li><strong>Cache server</strong>：不解碼 <code>%2f</code>，認為是 <code>/static/..%2fuser/carlos/profile</code>，匹配 <code>/static</code> 的 <strong>cache rule</strong>，儲存回應。</li>
<li>攻擊者訪問 <strong>URL</strong>，獲取快取資料。</li>
</ul>
</li>
<li><p><strong>結合分隔符</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile;%2f%2e%2e%2fstatic</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Cache server</strong>：解析為 <code>/static</code>，匹配 <strong>cache rule</strong>。</li>
<li><strong>Origin server</strong>：使用 <code>;</code> 作為 <strong>delimiter</strong>，解析為 <code>/user/carlos/profile</code>，返回個人資料。</li>
</ul>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>這就像騙櫃檯把機密文件存到「雜誌區」（<code>/static</code>），用一些特殊路徑（<strong>path traversal</strong>）讓書庫給出機密文件，櫃檯卻以為是雜誌。</p>
<p><strong>防禦</strong>：  </p>
<ul>
<li>對 <strong>URL path</strong> 進行嚴格 <strong>normalization</strong> 和 <strong>sanitization</strong>。</li>
<li>確保 <strong>cache rules</strong> 不覆蓋 <strong>Cache-Control: private</strong>。</li>
<li>使用 <strong>Burp Scanner</strong> 檢測 <strong>path traversal</strong> 漏洞。</li>
</ul>
<hr>
<h3 id="攻擊手法-5：Exploiting-File-Name-Cache-Rules（利用檔案名稱快取規則）"><a href="#攻擊手法-5：Exploiting-File-Name-Cache-Rules（利用檔案名稱快取規則）" class="headerlink" title="攻擊手法 5：Exploiting File Name Cache Rules（利用檔案名稱快取規則）"></a>攻擊手法 5：Exploiting File Name Cache Rules（利用檔案名稱快取規則）</h3><p><strong>定義</strong>：<br>攻擊者利用 <strong>cache rules</strong> 針對特定檔案名稱（如 <code>robots.txt</code>、<code>favicon.ico</code>）的特性，構造 <strong>URL</strong> 使 <strong>cache</strong> 儲存 <strong>dynamic content</strong>。</p>
<p><strong>原理</strong>：<br>某些檔案名稱被認為是靜態的，<strong>cache server</strong> 會自動儲存其回應。如果 <strong>origin server</strong> 將這些名稱解析為動態請求，可能導致 <strong>cache</strong> 儲存敏感資料。</p>
<p><strong>ShopEasy 攻擊方法</strong>：<br>攻擊者構造包含特定檔案名稱的 <strong>URL</strong>，誘導 <strong>cache</strong> 儲存受害者的資料。</p>
<p><strong>範例</strong>：  </p>
<ol>
<li><p><strong>檔案名稱攻擊</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile/favicon.ico</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Origin server</strong>：解析為 <code>/user/carlos/profile</code>，返回個人資料。</li>
<li><strong>Cache server</strong>：匹配 <code>favicon.ico</code> 的 <strong>cache rule</strong>，儲存回應。</li>
<li>攻擊者訪問 <strong>URL</strong>，獲取快取資料。</li>
</ul>
</li>
<li><p><strong>路徑穿越結合檔案名稱</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/aaa%2f%2e%2e%2frobots.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Cache server</strong>：解析為 <code>/robots.txt</code>，匹配 <strong>cache rule</strong>。</li>
<li><strong>Origin server</strong>：解析為動態端點，返回敏感資料。</li>
</ul>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>這就像騙櫃檯把機密文件當成「圖書館規則」（<code>robots.txt</code>）存起來，壞人後來去拿就拿到了。</p>
<p><strong>防禦</strong>：  </p>
<ul>
<li>驗證 <strong>Content-Type</strong> 與檔案名稱一致。</li>
<li>對特定檔案名稱的請求進行 <strong>access control</strong>。</li>
<li>使用 <strong>Cache-Control: no-store</strong> 防止誤快取。</li>
</ul>
<hr>
<h3 id="攻擊手法-6：Exploiting-Cache-Buster-Bypasses（利用快取破壞器繞過）"><a href="#攻擊手法-6：Exploiting-Cache-Buster-Bypasses（利用快取破壞器繞過）" class="headerlink" title="攻擊手法 6：Exploiting Cache Buster Bypasses（利用快取破壞器繞過）"></a>攻擊手法 6：Exploiting Cache Buster Bypasses（利用快取破壞器繞過）</h3><p><strong>定義</strong>：<br>攻擊者繞過 <strong>cache buster</strong>（快取破壞器，用於確保請求不被快取的機制），構造 <strong>URL</strong> 使 <strong>cache</strong> 儲存 <strong>dynamic content</strong>。</p>
<p><strong>原理</strong>：<br><strong>Cache buster</strong> 通常通過在 <strong>URL</strong> 中添加唯一 <strong>query parameter</strong>（如 <code>?cb=123</code>）改變 <strong>cache key</strong>。如果 <strong>cache server</strong> 忽略某些 <strong>query parameters</strong>，攻擊者可重複使用相同的 <strong>cache key</strong> 觸發快取。</p>
<p><strong>ShopEasy 攻擊方法</strong>：<br>攻擊者構造帶有忽略的 <strong>query parameter</strong> 的 <strong>URL</strong>，誘導 <strong>cache</strong> 儲存受害者的資料。</p>
<p><strong>範例</strong>：  </p>
<ol>
<li><p><strong>忽略查詢參數</strong>：<br>攻擊者構造 <strong>URL</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile.css?ignored=123</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Cache server</strong>：忽略 <code>?ignored=123</code>，認為是 <code>/user/carlos/profile.css</code>，儲存回應。</li>
<li><strong>Origin server</strong>：返回個人資料。</li>
<li>攻擊者訪問 <strong>URL</strong>，獲取快取資料。</li>
</ul>
</li>
<li><p><strong>多參數測試</strong>：<br>攻擊者嘗試：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shopeasy.com/user/carlos/profile.css?cb=123&amp;test=456</span><br></pre></td></tr></table></figure>
<p>如果 <strong>cache</strong> 忽略所有 <strong>query parameters</strong>，則儲存回應。</p>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>這就像櫃檯本來要用一個獨特標籤（<strong>cache buster</strong>）區分每本書，但壞人發現櫃檯忽略標籤，於是把機密文件存進去。</p>
<p><strong>防禦</strong>：  </p>
<ul>
<li>確保 <strong>cache key</strong> 包含所有 <strong>query parameters</strong>。</li>
<li>使用 <strong>Param Miner</strong> 測試忽略的 <strong>query parameters</strong>。</li>
<li>實施 <strong>rate limiting</strong> 防止大量測試。</li>
</ul>
<hr>
<h2 id="檢測-Web-Cache-Deception-的方法-Detecting-Web-Cache-Deception-Vulnerabilities"><a href="#檢測-Web-Cache-Deception-的方法-Detecting-Web-Cache-Deception-Vulnerabilities" class="headerlink" title="檢測 Web Cache Deception 的方法 &#x2F; Detecting Web Cache Deception Vulnerabilities"></a>檢測 Web Cache Deception 的方法 &#x2F; Detecting Web Cache Deception Vulnerabilities</h2><p>檢測 <strong>Web Cache Deception</strong> 需要分析 <strong>cache server</strong> 和 <strong>origin server</strong> 的行為差異。以下是具體步驟：</p>
<ol>
<li><p><strong>Identify Dynamic Endpoints</strong>（識別動態端點）：<br>使用 <a target="_blank" rel="noopener" href="https://portswigger.net/burp">Burp Suite</a> 檢查 <strong>GET</strong>、<strong>HEAD</strong> 或 <strong>OPTIONS</strong> 請求的回應，尋找返回 <strong>dynamic content</strong> 的端點（如 <code>/user/profile</code>）。</p>
</li>
<li><p><strong>Test Cache Behavior</strong>（測試快取行為）：  </p>
<ul>
<li>檢查 <strong>response headers</strong>：<ul>
<li><code>X-Cache: hit</code> 表示快取命中。</li>
<li><code>X-Cache: miss</code> 表示未快取，但可能在第二次請求時儲存。</li>
<li><code>Cache-Control: public, max-age&gt;0</code> 表示可快取。</li>
</ul>
</li>
<li>比較回應時間：快取回應通常更快。</li>
</ul>
</li>
<li><p><strong>Probe Discrepancies</strong>（探測差異）：  </p>
<ul>
<li>測試 <strong>path mapping</strong>：添加任意路徑（如 <code>/user/profile/foo</code>），檢查是否仍返回 <strong>dynamic content</strong>。</li>
<li>測試 <strong>delimiter</strong>：添加字符（如 <code>;</code>、<code>.</code>），檢查 <strong>origin server</strong> 和 <strong>cache</strong> 的解析。</li>
<li>測試 <strong>normalization</strong>：使用 <strong>path traversal</strong>（如 <code>/static/..%2fprofile</code>），檢查是否快取。</li>
</ul>
</li>
<li><p><strong>Use Cache Buster</strong>（使用快取破壞器）：<br>使用 <strong>Param Miner</strong> 為每個請求添加唯一 <strong>query parameter</strong>，確保測試不受快取影響。</p>
</li>
</ol>
<p><strong>範例</strong>：<br>發送請求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /user/carlos/profile.css HTTP/1.1</span><br><span class="line">Host: shopeasy.com</span><br></pre></td></tr></table></figure>
<p>檢查 <strong>X-Cache</strong> 標頭，若為 <code>hit</code>，表示回應被快取，可能存在漏洞。</p>
<p><strong>白話解釋</strong>：<br>這就像檢查櫃檯（<strong>cache</strong>）和書庫（<strong>origin server</strong>）怎麼處理書名，看它們是不是對同一個名字有不同理解，然後試試能不能騙櫃檯存機密文件。</p>
<hr>
<h2 id="防禦-Web-Cache-Deception-的策略-Defense-Strategies-Against-Web-Cache-Deception"><a href="#防禦-Web-Cache-Deception-的策略-Defense-Strategies-Against-Web-Cache-Deception" class="headerlink" title="防禦 Web Cache Deception 的策略 &#x2F; Defense Strategies Against Web Cache Deception"></a>防禦 Web Cache Deception 的策略 &#x2F; Defense Strategies Against Web Cache Deception</h2><p>以下是防禦 <strong>Web Cache Deception</strong> 的最佳實踐：</p>
<ol>
<li><p><strong>Use Cache-Control Headers</strong>（使用快取控制標頭）：  </p>
<ul>
<li>對 <strong>dynamic content</strong> 設置 <code>Cache-Control: no-store, private</code>。</li>
<li>確保 <strong>CDN</strong> 不覆蓋 <strong>Cache-Control</strong> 設定。</li>
</ul>
</li>
<li><p><strong>Verify Content-Type</strong>（驗證內容類型）：  </p>
<ul>
<li>啟用 <strong>CDN</strong> 的 <strong>Content-Type</strong> 驗證，確保 <code>.css</code> 回應的 <strong>Content-Type</strong> 為 <code>text/css</code>。</li>
<li>使用 <strong>Cloudflare Cache Deception Armor</strong>。</li>
</ul>
</li>
<li><p><strong>Standardize URL Parsing</strong>（標準化 URL 解析）：  </p>
<ul>
<li>統一 <strong>cache</strong> 和 <strong>origin server</strong> 的 <strong>path mapping</strong>、<strong>delimiter</strong> 和 <strong>normalization</strong> 邏輯。</li>
<li>測試常見 <strong>delimiter</strong>（如 <code>;</code>、<code>.</code>、<code>%00</code>）。</li>
</ul>
</li>
<li><p><strong>Sanitize URLs</strong>（清理 URL）：  </p>
<ul>
<li>過濾異常 <strong>URL path</strong>，如包含 <strong>path traversal</strong> 或未預期的 <strong>delimiter</strong>。</li>
<li>使用 <strong>regular expressions</strong> 檢查 <strong>URL</strong> 格式。</li>
</ul>
</li>
<li><p><strong>Regular Testing</strong>（定期測試）：  </p>
<ul>
<li>使用 <strong>Burp Scanner</strong> 或 <strong>Web Cache Deception Scanner BApp</strong> 檢測漏洞。</li>
<li>模擬攻擊，測試 <strong>cache rules</strong> 的安全性。</li>
</ul>
</li>
<li><p><strong>Access Control</strong>（存取控制）：  </p>
<ul>
<li>對 <strong>dynamic content</strong> 實施 <strong>authentication</strong>（身份驗證），防止未授權訪問。</li>
<li>限制 <strong>cache</strong> 儲存未驗證的回應。</li>
</ul>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>防禦就像教櫃檯（<strong>cache</strong>）嚴格檢查書名（<strong>URL</strong>），不要存機密文件（<strong>dynamic content</strong>），並確保書庫（<strong>origin server</strong>）和櫃檯用一樣的規則。</p>
<hr>
<h2 id="實際案例分析-Real-World-Examples-and-Case-Studies"><a href="#實際案例分析-Real-World-Examples-and-Case-Studies" class="headerlink" title="實際案例分析 &#x2F; Real-World Examples and Case Studies"></a>實際案例分析 &#x2F; Real-World Examples and Case Studies</h2><p><strong>Web Cache Deception</strong> 是相對新興的威脅，以下是基於現實風險的假想案例：</p>
<ol>
<li><p>**User Data Leak (2024)**：<br>一家電商網站因 <strong>static extension cache rule</strong> 漏洞，導致用戶的個人資料被快取，攻擊者通過構造 <strong>URL</strong> 獲取數千用戶的電子郵件和訂單資訊。</p>
</li>
<li><p>**Order History Exposure (2025)**：<br>攻擊者利用 <strong>delimiter discrepancy</strong>，誘導 <strong>cache</strong> 儲存受害者的訂單歷史，導致隱私洩露和法律訴訟。</p>
</li>
</ol>
<p><strong>白話解釋</strong>：<br>這些案例就像櫃檯不小心把客戶的訂單資料當成雜誌存起來，壞人拿走後，網站被客戶告上法庭。</p>
<hr>
<h2 id="結論-Conclusion"><a href="#結論-Conclusion" class="headerlink" title="結論 &#x2F; Conclusion"></a>結論 &#x2F; Conclusion</h2><p><strong>Web Cache Deception</strong> 是一種利用 <strong>cache server</strong> 和 <strong>origin server</strong> 行為差異的嚴重漏洞，可能導致 <strong>data breaches</strong> 和 <strong>unauthorized access</strong>。通過了解 <strong>web cache</strong> 的運作原理、攻擊手法和防禦策略，開發者可有效保護網頁應用程式。對於初學者，學習 <strong>Web Cache Deception</strong> 不僅提升安全意識，還能深入理解 <strong>HTTP</strong> 和 <strong>CDN</strong> 的運作。建議使用 <a target="_blank" rel="noopener" href="https://portswigger.net/burp">Burp Suite</a> 進行實戰練習，並參考 <a target="_blank" rel="noopener" href="https://portswigger.net/research/gotta-cache-em-all">PortSwigger Web Cache Deception Whitepaper</a> 獲取更多資訊。</p>
<hr>
<p><strong>Key Citations</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-deception">PortSwigger - Web Cache Deception</a></li>
<li><a target="_blank" rel="noopener" href="https://portswigger.net/research/gotta-cache-em-all">PortSwigger - Gotta Cache ‘em All Whitepaper</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cloudflare.com/">Cloudflare - Cache Deception Armor</a></li>
<li><a target="_blank" rel="noopener" href="https://owasp.org/">OWASP - Web Cache Deception</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/05/07/InsecureDeserialization/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Insecure Deserialization
        
      </div>
    </a>
  
  
    <a href="/2025/05/06/SQLI/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">SQL Injection</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 Noflag
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>